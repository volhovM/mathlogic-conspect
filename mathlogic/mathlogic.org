#+TODO: X 0 1 2 | OK
#+OPTIONS: tex:verbatim
#+TITLE: Курс математической логики по Штукенбергу Д.Г.

Должно отображаться корректно: x₁, x₂, x₃, xₙ, θ, ∃, ∑, ∉.

Mikhail Volkhov, 2538, 2014

* О чём речь
  Мы работаем с формальными системами. Формальная система определяется
  сигнатурой, грамматикой, набором аксиом и набором правил вывода.
  1. Сигнатура ФС - это (Pr, F, C, Links, Misc, arity):
     * Pr - описывает предикаты (Num + BigLatinChar)
     * F - множество функций (большие заглавные латинские чары)
     * C - описывает константы
     * Links - множество связок ({"->", "∪", " "})
     * Misc - дополнительные элементы ({"(", ")", " "})
     * arity: Foo ∪ Pr ∪ C → N возвращает арность
  2. Грамматика описывает то, как мы можем строить выражения
     в соответствии с нашей сигнатурой.
  3. Аксиомы - выражения в нашей грамматике.
  4. Правила вывода – пары вида (List, List), где List -
     список утверждений. Первый элемент – посылки, второй -
     то, что из них следует.

  Иногда нам хочется что-то посчитать и мы прикручиваем к
  формальной системе модель - корректную структуру с оценкой.
  Структура - это сигнатура с интерпретацией и носителем.
  1. Сигнатура структуры - (R, F, C, arity):
     * Pr - множество символов для предикатов
     * F - функциональных символов
     * С - символов констант
     * arity – функция, определяющая арность Pr ∪ F → N.
  2. Интерпретация - это приписывание символам значения
     и правил действия (отображения из Pr ∪ F ∪ C в носитель)
  3. Носитель - это объединение множеств, в котором обязательно
     присутствует V - множество истинностных значений. Если же
     мы рассматриваем только нульместные предикаты, на этом
     можно остановится, otherwise часто вводится P - предметное
     множество, в которое отображаются элементы из F, C.

  Эта реализация структуры не определяет ничего про аксиоматику, но
  аксиоматически заданные структуры существуют – например в ФА есть
  Пеано.

  Если все аксиомы тавтологии, то структура корректна.
  В таком случае она называется моделью.

  Оценку иногда определяют раньше\позже чем модель, удобно думать о
  ней, как об отдельной сущности, потому что она связывает модель с
  ФС. Оценка - это функция оценки и функция тавтологии.
  1. Функция оценки - отображение из (множества всех формул,
     сгенеренных грамматикой) x (какие-нибудь допаргументы)
     в V модели. Дополнительные аргументы - например оценки
     элементов связки.
  2. Функция тавтологии - отображение из множества формул
     грамматики в {0, 1} - является ли формула тавтологией.
     Тавтология использует функцию оценки. Например, тавтология
     - это выражение, оценка которого на любых аргументах
     возвращает σ ∈ V - какой-то элемент V.

  Когда говорится "сигнатура модели" - имеется в виду она сама. Когда
  говорится "сигнатура ФС" - имеется в виду скорее всего объединение
  сигнатур, а может только сигнатура самой ФС. Первый вариант более
  вероятен.
* Ticket 1: ИВ
** Определения (исчисление, высказывание, оценкa...)
   Формальная система с алгеброй Яськовского J₀ в качестве модели
   (множество истинностных значений {0, 1}). Формальная теория
   нулевого порядка, кванторов нету, предикаты - это пропозициональные
   переменные.
** Общезначимость, доказуемость, выводимость
   * Общезначимость формулы - ее свойство в теории с моделью. Общезначимость
     можно определить как угодно, в принципе. Например в ИВ общезначимость -
     это что оценка формулы на любых значениях свободных переменных отображает
     в 1. В модели крипке - существование формулы во всех мирах и т.д.
   * Доказуемость - свойство формулы в теории, значащее, что существует
     доказательство для этой формулы. Доказательство для теории тоже определяется
     по разному (последовательность утверждений, каждое из которых есть аксиома
     или следует по правилу вывода из предыдущих в ИВ, дерево с выводами в S∞)
   * Выводимость - в общем случае часто используется как аналог доказуемости,
     в ИВ это доказуемость из всего, что и ранее + из посылок.
** Схемы аксиом и правило вывода
   Аксиомы:
   1. a → b → a
   2. (a → b) → (a → b → c) → (a → c)
   3. a → b → a & b
   4. a & b → a
   5. a & b → b
   6. a → a V b
   7. b → a V b
   8. (a → b) → (c → b) → (a V c → b)
   9. (a → b) → (a → ¬b) → ¬a
   10. ¬¬a → a

   Правило вывода:
   MP: ⊢ A and ⊢ A → B => ⊢ B
** Теорема о дедукции
   → Если нужно переместить последнее предположение вправо,
   то рассматриваем случаи -- аксиома или предположение,
   MP, это самое выражение.
   1. A
      A→a→A
      a→A
   2. (там где-то сзади уже было a→A, a→A→B)
      (a→A)→(a→A→B)→(a→B)
      (a→A→B)→(a→B)
      a→B
   3. A→A умеем доказывать

   ← Если нужно переместить влево, то перемещаем, добавляем
   A→B (последнее)
   A   (перемещенное)
   B
** Корректность исчисления высказываний относительно алгебры Яськовского
   * Индукцией по доказательству -- если аксиома, то она
     тавтология, все ок. Если модус поненс, то таблица
     истинности для импликации и все ок
* Ticket 2: полнота ИВ
  Полнота исчисления высказываний относительно алгебры Яськовского.

  Можно доказывать маханием руками как для предикатов, и я не могу
  утверждать, что при таком подходе ИВ не будет полно относительно
  любой модели.
** Контрапозиция
   Хотим: (a → b) → (¬b → ¬a)
   (a → b), ¬b ⊢ ¬a
   a → b
   (a → b) → (a → ¬b) → ¬a
   (a → ¬b) → ¬a
   ¬b → a → ¬b
   ¬b
   a → ¬b
   ¬a
   +2 раза дедукцию применить
** Правило исключененного третьего
   С помощью контрапозиции доказываем два утверждения:

   ¬(A|¬A)→¬A (один раз контрапозицию от этого обратную, там A→(A|¬A) акс)
   ¬(A|¬A)→¬¬A

   Потом девятую аксиому и снимаем двойное отрицание
** Всякие очевидные вещи вроде "если выводится из А и из Б то из А и Б тоже"
** Правило со звездочкой (14 доказательств)
   1. a, b ⊢ a V b
      a
      a → a V b
      a V b
   2. a, ¬b ⊢ a V b
      a
      a → a V b
      a V b
   3. ¬a, b ⊢ a V b
      b
      b → a V b
      a V b
   4. ¬a, ¬b ⊢ ¬(a V b)
      ¬a
      ¬b
      (a V b → a) → (a V b → ¬a) → ¬(a V b)
      ¬a → a V b → ¬a
      a V b → ¬a
      #
      ¬a, ¬b, a V b ⊢ a
      ¬a
      ¬b
      a V b
      a → a
      ... //д-во ¬b, ¬a ⊢ b → a
      b → a
      (a → a) → ((b → a) → (a V b → a))
      (b → a) → (a V b → a)
      a V b → a
      a
      # -> a V b → a
      a V b → a
      (a V b → ¬a) → ¬(a V b)
      ¬(a V b)
   5. a, b ⊢ a & b
      a
      b
      a → b → a & b
      b → a & b
      a & b
   6. a, ¬b ⊢ ¬(a & b)
      ¬b
      ((a & b) → b) → ((a & b) → ¬b) → ¬(a & b)
      a & b → b
      (a & b → ¬b) → ¬(a & b)
      ¬b → a & b → ¬b
      a & b → ¬b
      ¬(a & b)
   7. ¬a, b ⊢ ¬(a & b)
      аналогично
   8. ¬a, ¬b ⊢ ¬(a & b)
      аналогично
   9. a, b ⊢ a → b
      b
      b → a → b
      a → b
   10. a, ¬b ⊢ ¬(a → b)
       a
       ¬b
       ¬b → ((a → b) → ¬b)
       (a → b) → ¬b
       #
       a, ¬b, a → b ⊢ b
       a
       a → b
       b
       #
       (a → b) → b
       ((a → b) → b) → ((a → b) → ¬b) → ¬(a → b)
       ((a → b) → ¬b) → ¬(a → b)
       ¬ b → (a → b) → ¬b
       (a → b) → ¬b
       ¬(a → b)
   11. ¬a, b ⊢ a → b
       b
       b → a → b
       a → b
   12. ¬a, ¬b ⊢ a → b
       def implicationFF(a: Expr, b: Expr): Derivation =
       mkD(List(¬¬(a), ¬¬(b)), simpleDeductionApply(mkD(List(¬¬(a), ¬¬(b), a), List(
       ¬¬(a),
       ¬¬(b),
       a,
       (¬¬(b) → a) → ((¬¬(b) → ¬¬(a)) → ¬¬(¬¬(b))),
       a → (¬¬(b) → a),
       ¬¬(b) → a,
       ¬¬(a) → (¬¬(b) → ¬¬(a)),
       ¬¬(b) → ¬¬(a),
       (¬¬(b) → ¬¬(a)) → ¬¬(¬¬(b)),
       ¬¬(¬¬(b)),
       ¬¬(¬¬(b)) → b,
       b
       )))._2)

   13. a ⊢ ¬¬a
       9 акс
   14. ¬a ⊢ ¬a
       ¬a
** Лемма об исключении последнего в предположениях
   Γ, P ⊢ a, Γ, ¬P ⊢ a => Γ ⊢ a
   Докажем, что если Г ⊢ P→A, Г ⊢ ¬P→A, то A
   P→A
   ¬P→A
   PV¬P
   (P→A)→(¬P→A)→(PV¬P→A)
   три раза MP
* Ticket 3: ИИВ
  Подробнее: читать "Плиско Хаханян: Интуиционистская логика".
** ИИВ, структура, модель
   Сигнатура - (R, F, C, r): R - множество символов для
   предикатов, F - функциональных символов, С - символов
   констант, r – функция, определяющая арность x ∈ R V F.
   Интерпретация - это приписывание символам значения
   и правил действия
   Структура - это носитель M (множство истинностных значений),
   сигнатура и интерпретация над носителем. Если все аксиомы
   верны, то структура корректна. В таком случае она называется
   моделью.
   Выкидываем 10 аксиому, добавляем A→(¬A→B)
   10i: a → ¬a → b
   Кстати она доказывается и в ИВ
   1. (a → aV¬a) → (a → aV¬a → (¬a → b)) → a → (¬a → b)
   2. a, aV¬a, ¬a ⊢ b
      a
      ¬a
      b → a
      b → ¬a
      (b → a) → (b → ¬a) → ¬b
      ¬b → a
      ¬b → ¬a
      (¬b → a) → (¬b → ¬a) → ¬¬b
      ¬¬b → b
      b
   3. a → (¬a → b)
** Опровергаемость исключенного третьего
   Вводим в наше множество истинностных значений Н
   Л < Н < И
   & - min
   V - max
   ¬И=Л, ¬Л=И, ¬Н=Л
   И→x=x, Л→x=И, Н→Л=Л, Н→Н=И, Н→И=И
   1. Все аксиомы ИИВ являются 3-тавтологиями (ручная проверка)
      Значит любая интуиционистски выводимая формула 3-тавтология
   2. q V ¬q = H, значит она невыводима (контрпозиция пред. утв)
** Решетки
   * Решетка - это (L, +, *) в алгебраическом смысле и (L, ≤) в порядковом.
     Решетку можно определить как алгебраическую структуру через
     аксиомы: коммутативность, ассоциативность, поглощение.
     Решетку можно определить как упорядоченное множество через
     множество с частичным порядком на нем, тогда операции +, * определяются
     как sup и inf:
     sup p = min {u | u ≥ all s ∈ p}
     inf p = max {u | u ≤ all s ∈ p}
     a + b = sup {a, b}
     a * b = inf {a, b}
     Если для двух элементов всегда можно определить a + b и a * b, то такое
     множество назывется решеткой. Отметим, что если под min
     встречаются несравнимые элементы, то мы проиграли. Отсюда вывод
     -- sup/inf должен быть однозначно определим и один.
   * Дистрибутивная решетка -- решетка, в которой работает дистрибутивность:
     a * (b + c) = (a * b) + (b * c)
   * Импликативная решетка -- всегда существует псевдодополнение a
     относительно b: (a → b)

     a → b = max c | c * a ≤ b

     Имеет свойствa, что в ней всегда есть максимальный элемент a → a и что
     она дистрибутивна.
** Лемма о дистрибутивности импликативной решетки
   1. Полезные леммы
      1) Лемма о домножении слева
         b ≤ c ≤ a * c, тогда a * b ≤ a * c
         a * b ≤ b ≤ c ≤ a * c
      2) Лемма о перенесении импликации
         a * b ≤ c => a ≤ b → c
   2. a * (b + c) ≥ a * b + a * c
      1) a * (b + c) ≥ a * b
         a * b ≤ a
         a * b ≤ b ≤ b + c
         a * b ≤ a * (b + c)  (из двух предыдущих)
      2) a * (b + c) ≥ a * c
         a * c ≤ a
         a * c ≤ c ≤ b + c
         a * c ≤ a * (b + c)
      3) a * (b + c) ≥ a * b + a * c (поскольку оно больше и того и другого)
   3. a * (b + c) ≤ a * b + a * c (пусть правая часть - q)
      1) b * a ≤ q (по определению *)
         b ≤ a → q (то самое место где мы пользуемся импликативностью)
      2) c * a ≤ q
         c ≤ a → q
      3) b + c ≤ a → q
         (b + c) * a ≤ q
         a * (b + c) ≤ q = a * b + a * c
   4. a * (b + c) = a * b + a * c
** Алгебра Гейтинга, булева алгебра
   * Псевдобулева алгебра (алгебра Гейтинга) - это импликативная
     решетка над фундированным множеством с ¬a = (a → 0), 1 = a → a.
   * Булева алгебра можно определить так:
     1. (L, +, *, -, 0, 1) с выполненными аксиомами - коммутативность,
        ассоциативность, поглощение, две дистрибутивности и a * -a = 0,
        a + -a = 1.
     2. Псевдобулева алгебра с a + -a = 1. Импликативная решетка над
        фундированным множеством.
** Алгебра Линденбаума-Тарского
   V - множество формул ИИВ
   * Порядок для решетки:
     a ≤ b ↔ a ⊢ b
     a ~ b ↔ a ⊢ b & b ⊢ a
   * Дополняяем множество V:
     0: a & ¬a = ⊥
     1: a → a = T
   * Операции в алгебра:
     *: a & b
     +: a V b
     →: a → b
     -: ¬a
   * Эта алгебра является алгеброй Гейтинга, поскольку для нее
     выполняются -a * a = 0 (по определению), а 0: ∀ x : x ≤ 0
     в ней это ∀ x (x – формула ИИВ) : ⊥ ⊢ x (из лжи следует все что угодно):
     a & ¬a
     a & ¬a → a
     a & ¬a → ¬a
     (b → a) → (b → ¬a) → ¬b (ну или 10i в ИИВ)
** Теорема о полноте ИИВ относительно алгебры Гейтингa
   Давайте возьмем в качестве Гейтинга алгебру Л-Т. Она нормальная
   себе такая структура (модель, наверное, несложно проверить):
   Пользуемся стандартной топологической интерпретацией
   (& = *, V = +, → = →, ¬ = -)
   Алгебра
   * Доказательство полноты
     a - общезначимо
     [a] = 1
     1 ≤ [a]
     x → x ⊢ a (по определению алгебры Л-Т)
     x → x доказума и так, значит
     ⊢ a
   * Дойдем до 1 ≤ [a], значит A → A ⊢ a
** Дизъюнктивность ИИВ
   Мы доказываем, что если ⊢ aVb, то ⊢a или ⊢b
   * Будем использовать алгебру Гёделя Г(A) (γ – функция
     преобразования a → a_godel).

     Мы можем ее обернуть над любой Гейтинговой алгеброй, возьмем Л-Т.
     Алгебра Гёделя строится с помощью γ. γ(a) = b значит, что в
     алгебре A элементу а соответствует элемент b из алгебры Гёделя.
     Порядок сохраняется естественным образом (я не очень точно знаю
     как, но предполагается, что a ≤ b, a и b сравнимы - γ(a) ≤ γ(b),
     они сравнимы. Ну и такое).

     Гёделева алгебра добавляет один элемент w.
     γ(1) = w
     γ(x) = x

     Таким образом Г(А) = А∪{w}, порядок в Г(А):
     * a≤w если a!=1
     * a≤b ←→ a≤ₐa (сравнение обычных элементов как и раньше)
     * w≤1

     Связки определяем через таблицы:

     |--------+-----+--------|
     | x + y  | y=1 | y=γ(v) |
     |--------+-----+--------|
     | x=1    |   1 | 1      |
     | x=γ(u) |   1 | γ(u+v) |
     |--------+-----+--------|

     |--------+---------+---------|
     | x * y  | y=1     | y=γ(v)  |
     |--------+---------+---------|
     | x=1    | 1       | γ(x*ₐv) |
     | x=γ(u) | γ(u*ₐy) | γ(u*ₐv) |
     |--------+---------+---------|

     |--------+-----+---------|
     | x → y  | y=1 | y=γ(v)  |
     |--------+-----+---------|
     | x=1    |   1 | γ(x→ₐv) |
     | x=γ(u) |   1 | u→ₐv    |
     |--------+-----+---------|

     |--------+--------|
     | x      | ¬x     |
     |--------+--------|
     | x=1    | γ(¬ₐx) |
     | x=γ(u) | ¬ₐu    |
     |--------+--------|

   * Докажем, что Гёделева алгебра является Гейтинговой.  Для этого
     нужно доказать, что в ней выполняется коммутативность,
     ассоциативность и законы поглощения (это альтернативное
     определение эквивалентно заданию множества с фундированным
     порядком).
     1. Коммутативность
        1) A * B = B * A
        2) A + B = B + A
     2. Ассоциативность
        1) A * (B * C) = (A * B) * C
        2) A + (B + C) = (A + B) + C
     3. Поглощение
        1) A * (A + B) = A
        2) A + (A * B) = A
     Внимательноe прослеживание свойств связок подтверждает тот факт,
     что Гёделева алгебра есть алгебра Гейтинга. Нужно также учитывать
     тот факт, что внутренняя алгебра тоже Гейтингова.
   * Если ⊢ a V b, то [a V b]ₗ = 1, [a V b]_Г = 1, тогда по определению
     связки + в Гёделевской [a]_Г = 1 или [b]_Г = 1, тогда оно такое же
     и в Линденбауме-Тарском, а Л-Т полно, то есть ⊢a или ⊢b.
** Теорема Гливенко
   Если F выводима в ИВ, то ¬¬F выводима в ИИВ.

   1. Заметим, что если А доказуемо в ИИВ, то ¬¬А тоже доказуемо.
      A
      A → ¬A → A
      ¬A → A
      ¬A → ¬A (как обычно)
      (¬A → A) → (¬A → ¬A) → ¬¬A
      Значит если А - аксиома по схеме 1-9, то ¬¬A доказуемо в ИИВ
   2. Пусть выражение А получилось по 10 схеме классического ИВ
      F = ¬¬A → A
      Докажем:
      A → ¬¬A → A (акс. 1)
      ¬(¬¬A → A) → ¬A (к/поз)
      ¬A → ¬¬A → A (акс. 10и)
      ¬(¬¬A → A) → ¬¬A (к/поз)
      (¬(¬¬A → A) → ¬A) → (¬(¬¬A → A) → ¬¬A) → ¬¬(¬¬A → A) (акс. 9)
      ¬¬(¬¬A → A) (2x m.p.)
   3. Делаем индукцию по длине доказательства в ИВ:
      1. А - аксиома, !!(А) доказывается по пункту 1-2
      2. MP
         A
         A → B
         B

         В ИИВ имеем
         ¬¬(A)
         ¬¬(A → B)
         (¬B → ¬A) → (¬B → ¬¬A) → ¬¬B

         ¬¬A, ¬¬(A → B), ¬B ⊢ ¬A
         (A → ¬(A → B)) → (A → ¬¬(A → B)) → ¬A

         ¬¬A, ¬¬(A → B), ¬B, A ⊢ ¬(A → B)
         ((A → B) → B) → ((A → B) → ¬B) → ¬(A → B)

         ¬¬A, ¬¬(A → B), ¬B, A, A → B ⊢ B
         A
         A → B
         B
** Топологическая интерпретация
   Булеву алгебру и алгебру Гейтинга можно интерпретировать на
   множестве Rⁿ. Тогда заключения о общезначимости формулы можно
   делать более наглядно.

   Давайте возьмем в качестве множества алгебры все открытые
   подмножества Rⁿ. Определим операции следующим образом:
   1. a + b => a ∪ b
   2. a * b => a ∩ b
   3. a → b => Int(aᶜ ∪ b)
   4. -a => Int(aᶜ)
   5. 0 => ∅
   6. 1 => ⋃{всех мн-в в L}

   Более того, ИИв корректно и полно относительно R.
* Ticket 4: ИИВ2
** Модели Крипке
   Var = {P, Q, ...}
   Модель Крипке – это <W, ≤, v>, где
   * W - множество "миров"
   * ≤ - частичный порядок на W (отношение достижимости)
   * v: W × Var → {0, 1} - оценка перменных на W, монотонна
     (если v(x, P) = 1, x ≤ y, то v(y, P) = 1 – формулу нельзя un'вынудить)
   Правила:
   * W, x ⊨ P ⇐⇒ v(x, P) = 1 если P ∈ Var
   * W, x ⊨ (A & B) ⇐⇒ W, x ⊨ A & W, x ⊨ B
   * W, x ⊨ (A V B) ⇐⇒ W, x ⊨ A V W, x ⊨ B
   * W, x ⊨ (A → B) ⇐⇒ ∀ y ≥ x (W, y ⊨ A ⇒ W, y ⊨ B)
   * W, x ⊨ ¬A ⇐⇒ ∀ y ∈ x (W, x ¬⊨ A)

   В мире разрешается быть не вынужденной переменной и ее отрицанию
   одновремеменно.
   Формула называется тавтологией в ИИВ с моделью Крипке, если она
   истинна (вынуждена) в любом мире любой модели Крипке.
** Корректность ИИВ относительно моделей Крипке
   Если формула выводима в ИИВ, то она истинна по шкале Крипке
   Проверим MP и аксиомы (что они истинны во всех мирах)
   1. MP
      По определению импликации в моделях Крипке, если в мире
      вынуждено A, A→B, то вынуждено и B.
   2. Аксиомы
      1) A → (B → A)
         Пусть где-нибудь вынуждена A, в силу
         монотонности она вынуждена везде правее, тогда если
         там где-то будет B, то B → A тоже будет вынуждено
      2) (A → B) → ((A → (B → C)) → (A → C))
         Пусть где-нибудь вынуждено A → B, докажем, что если
         где-то есть A → B, то там есть и ((A → (B → C)) → (A → C)).
         1. В мире вынуждено A, B; тогда если правее вынуждено
            A → (B → C), то вынуждено C по монотонности A, B; значит
            Везде правее A → (B → C) есть A, B, C, значит вынуждено A → C;
         2. В мире не вынуждено ни A, ни B, тогда если не вынуждено
            A → (B → C), то A → C тоже не может быть вынуждено, потому что
            ни A, ни B, ни C там нет.
      3) A → (¬A → B)
         1. Если вынуждена А, то вынуждена ¬A → B
            Если вынуждена А, то не вынуждена ¬A, тогда ¬A → B
            можно вынудить вне зависимости от вынужденности B.
         2. Если не вынуждена А, то что угодно нас устроит.
      4) etc (как-то легко на уровне)
** X Вложение Крипке в Гейтинга (Д-во псевдодоп-я)
   Нарисуем модель Крипке, возьмем какое-то объединение поддеревьев
   со всеми потомками, каждое такое объединение пусть будет входить
   в алгебру Гейтинга. ≤ - отношение "быть подмножеством".
   Определим операции:
   + = ∪, * = ∩,
   Докажем, что с ними все ок:
   ≤ - частичный порядок.
   1. Антисимметричность - a ∈ b & b ∈ a => a = b
   2. Транзитивность - a ∈ b, b ∈ c => a ∈ c
   3. Рефлексивность - ∀ a (a ∈ a)

   +, * замкнуты. Объединение сохраняет свойства поддеревьев, а
   пересечение может быть либо пустым, либо поддеревом одного из
   аргументов, в любом случае все ок. Можно пользоваться строгим условием
   монотонности миров.

   Докажем, что + - это sup, * - inf.
   1. sup
      a + b ≤ x <=> a ≤ x & b ≤ x - верхняя граница
      a ∪ b ⊂ x <=> a ⊂ x & b ⊂ x - выполняется
   2. inf
      x ≤ a * b <=> x ≤ a & x ≤ b - нижняя граница
      x ⊂ a ∩ b <=> x ⊂ a & x ⊂ b - выполняется

   Определим 0 как ∅;
   a → b = ∪T(x, y), где T(x, y) = {z ∈ H | z ≤ xᶜ ∪ y}
   Доказать, что a → b - псевдодополнение,
   a ≤ b → c ~ a * b ≤ c
   -->   TODO

   Докажем, что если в Крипке что-то общезначимо, то оно общезначимо
   и в созданной алгебре Гейтинга.
   Делается индукцией по структуре. А - булева алгебра, М - модель крипке
   ⊨ₘ a <=> ⊨ₐ a
   Пусть оценка a в нашей алгебре Гейтинга - это множествo, являющеeся
   объединением всех поддеревьев миров, в которых вынуждено а. Общезначимо
   значит равно объединению всех множеств V в нашей алгебре.
   Если переменная в Крипке тавтология, то она вынуждена во всех мирах,
   значит ее оценка в Гейтинге = 1
   Нужно еще проверить все связки.
** Полнота ИИВ в моделях Крипке
   1. Докажем для дизъюнктивных множество такое:
      Пусть дизъюнктивная множество M – это такое, что если в
      формальной системе M⊢aVb, то a ∈ M или b ∈ M.
      (inb4: носитель модели крипке является дизъюнктивным мн-м, поскольку
      если в ИИВ доказано aVb, то оно по корректности вынуждено во всех
      мирах, а значит вынуждено одно из двух, а значит принадлежит множеству
      вынужденных формул шкал Крипке)
      * В дизъюнктивном множестве, если G ⊢ a, то a ∈ G.
        Пусть это не так.
        В нашем множестве мы можем иметь что угодно. a → a V ¬a,
        тогда G ⊢ a V ¬a. Пусть a ¬∈ G, тогда по дизъюнктивности M ¬a ∈ G.
        Но тогда мы можем доказать a&¬a.
   2. Возьмем множество всех дизъюнктивных множеств с формулами из ИИВ.
      Мы можем это сделать, потому что ИИВ дизъюнктивно.
      Для любого элемента Wᵢ a, a ∈ Wᵢ значит что в этом мире а вынуждено.
      Построим дерево с порядком "быть подмножеством".
      Докажем, что это множество – модель крипке.
      Проверим 5 свойств (про монотонности всякие и вынужденности)
      1) W, x ⊨ P ←→ v(x, P) = 1 если P ∈ Var
         Монотонности выполняются по построению дерева
      2) W, x ⊨ (A & B) ←→ W, x ⊨ A & W, x ⊨ B
         W ⊢ A (через A & B → A), значит A ∈ W, B аналогично
      3) W, x ⊨ (A V B) ←→ W, x ⊨ A V W, x ⊨ B
         По дизъюнктивности (если лежит в W, значит из него доказуемо)
      4) W, x ⊨ (A → B) ←→ ∀ y ≥ x (W, y ⊨ A ⇒ W, y ⊨ B)
         W ⊢ A → B. Пусть в W есть А, тогда докажем B (MP) и оно тоже в нем
         Пусть есть B, тогда все уже хорошо
      5) W, x ⊨ ¬A ←→ ∀ y ∈ x (W, x ¬⊨ A)
         Если вдруг где-то нашлось A, то оно доказуемо, значит мы сможем
         доказать A & ¬A
   3. ⊨a, тогда Wᵢ⊨a, но для W₀ - дизъюнктивного множества всех доказуемых
      формул W, W₀⊨a. W₀ такое, что что бы не было
      доказуемо из W₀, оно тоже лежит в нем. Поскольку a тавтология, то
      a была доказана и попала в W₀ не случайно.
** ИИВ не таблично
   Под этим мы подразумеваем, что не существует полной модели, которая
   может быть выражена таблицей (конечной – алгебра Гейтинга и Крипке
   не табличны, так как и там и там связки определяются иначе).  От
   противного соорудим табличную модель и покажем, что она не полна.
   В ИВ мы обычно пользуемся алгеброй J₀ Яськовского
   - это V={0, 1}, 0 ≤ 1

   Пусть имеется V = {...}, |V| = n - множество истинностных значений.
   Пусть размер больше 2. Тогда построим формулу:

   ⋃_(1≤j<i≤n+1)(aᵢ→aⱼ)

   1. Общезначимость.
      По принципу Дирихле (количество таких формул - c(n, 2) ≥ n)
      В какой-то формуле встретятся два одинаковых значения и она будет верна,
      тогда все выражение будет истинно.
   2. Недоказуемость
      1) J₀ - алгебра Яськовского. Определим последовательность
         алгебр Lₙ, L₀ = J₀, Lₙ=Γ(Lₙ₋₁) - Гёделева алгебра

         Таким образом Lₙ - упорядоченное множество {0, ω₁, ω₂,...1}

         Пусть f - оценка в Lₙ, действующая по таким правилам на нашу
         формулу:

         f(a₁) = 0, f(aₙ₊₁) = 1, f(aᵢ) = wᵢ
         при j<i f(aᵢ → aⱼ) = f(aᵢ) → f(aⱼ) = f(aⱼ) ≠ 1

         Поскольку ИИВ полно относительно алгебры Гейтинга (Lₙ
         псевдобулева), то формула недоказуема
      2) Строим модель Крипке как вершину с n+1 сыновьями, в которых вынуждено
         по одной переменной. Тогда если в вершине вынуждена формула,
         то хотя бы один элемент связки должен быть вынужден, но там везде
         по одной переменной и импликация не работает.
* Ticket 5: Логика первого порядка
** Определения исчисления предикатов, грамматика
   Описываем грамматику (goto конспект ДГ). Описываем модель –
   предметное множество, формулы для функциональных символов и
   предикатов, задать свободные переменные.

   f: [f]:Dⁿ→D
   P: [P]:Dᵐ→V
   x: [x]:D

   (+ немного очевидные формальные правила как делать оценку - если
   ∀xP, то [...] = 1, если для любого x P == 1 и так далее)

   Добавляются две новые аксиомы:

   ∀x.A → A[x:=θ], где θ свободна для подстановки в A
   A[x:=θ] → ∃x.A, -//-

   Новое правило вывода (в дополнение к МП):
   A ⊢ ∀x.A    GEN (обобщение)

   Мы это правило представляем в виде двух утверждений (второй неочевидно откуда)
   _A_→_B_
   A → ∀x.B

   _A_→_B_
   ∃x.A → B

   переход от 1 к Gen легко доказать
   A
   A → ⊤ → A
   ⊤ → A
   ⊤ → ∀x.A
   ∀x.A

   Переход от Gen к 1
   A → B ⊢ A → ∀x.B
   ???

   В общем-то нам нет необходимости думать о том, как делать переход,
   но вопрос интересный (теорему Генцена о непротиворечивости ФА
   можно видоизменить с GEN на наши два правила)
** Теорема о дедукции
   → Если нужно переместить последнее предположение вправо,
   то рассматриваем случаи -- старая аксиома или предположение,
   MP, это самое выражение, две новых аксиомы с условиями выполнимости,
   два новых правила с условиями выполнимости.
   1. Старая аксиома или предположение
      A
      A → a → A
      a → A
   2. MP
      a → A (по индукции)
      ...
      a → A → B (по индукции)
      ...
      (a → A) → (a → A → B) → (a → B)
      (a → A → B) → (a → B)
      a → B
   3. A → A умеем доказывать
   4. Новые аксиомы как старые, только проверяем условие
   5. ∃x.A → B - первое новое правило вывода, проверяем условие
      1) Вспомогательная лемма: (a → (b → c)) → (b → (a → c))
         a → (b → c), b, a ⊢ c
         a → b → c
         b → c
         c
      2) a → A → B (в первоначальном доказательстве было A → B)
         ...
         (a → A → B) → (A → a → B)
         A → a → B
         ∃x.A → a → B (это же правило вывода)
         (∃x.A → a → B) → (a → ∃x.A → B)
         a → ∃x.A → B
   6. A → ∀x.B - второе новое правило вывода, проверяем условие
      1) Вспомагательная лемма 1: (a & b → c) → (a → b → c)
         a & b → c, a, b ⊢ c
         a
         b
         a → b → a & b
         b → a & b
         a & b
         a & b → c
         c
      2) Вспомагательная лемма 2: (a → b → c) → (a & b → c)
         a → b → c, a & b ⊢ c
         a & b → a
         a
         a & b → b
         b
         b → c
         c
      3) a → A → B
         ...
         (a → A → B) → (a & A → B)
         a & A → B
         a & A → ∀x.B
         (a & A → ∀x.B) → (a → A → ∀x.B)
         a → A → ∀x.B

   ← Если нужно переместить влево, то перемещаем, добавляем
   A→B (последнее)
   A    (перемещенное)
   B
   (тут все как в ИВ)
** Корректность исчисления предикатов
   * Лемма о корректности подстановки
     [a]^(x:=[θ]) = [a(x:=[θ])]

     Структурная индукция по a:
     База: Пусть a - это предикат, тогда из способа оценки предиката
     понятно, что [P(θ,..)]=[P(x,...)]^(x:=[θ])
     Индукционный переход:
     1. a → b, a & b, a V b, ¬a
        1) a & b:
           [a & b]^(x:=[θ]) = [a[x:=θ]] & [b[x:=θ]] = [a[x:=θ] & b[x:=θ]] =
           [(a & b)[x=[θ]]]
        2) аналогично, TODO
     2. ∀y.a, ∃y.a
        1) [∀y.a]^(x:=[θ]) =? [∀y.a[x:=θ]]
           Если x входит в ∀y.a связанно, то вообще никакой роли
           наша подстановка в оценке не играет.
           Значит пусть входит свободно.
           Поскольку θ свободна для подстановки вместо x в a, то
           в θ не входит свободно y - оценка θ не меняется.
           По предположению индукции [a]^(x:=[θ]) = [a[x:=θ]].
           Из свободности для подстановки θ следует еще и
           [a]^(x:=[θ], y:=v) = [a[x:=θ]]^(y:=v), значит оценки полных
           формул с кванторами тоже будут совпадать
        2) ∃ аналогично, TODO

   С помощью леммы проводим аналогичные рассуждения, как для ИВ.
   Рассматриваем только новые аксиомы и правила вывода:
   1. ∀x.a → a[x:=θ]
      Пусть это не тавтология, тогда ∀x.a = И, a[x:=θ] = Л.
      При любом x выполнено a, но с x=θ нет. Противоречие
   2. a[x:=θ] → ∃x.a
      аналогично, TODO
   3. a → b; a → ∀x.b
      a → b истинно по предположению индукции. Пусть a → ∀x.b ложь, тогда
      a = И, ∀x.b = Л, но b = (∀x.b)@θ, значит это есть частный случай, а
      он верен. противоречие
   4. a → b; ∃x.a → b
      аналогично, TODO
* Ticket 6: Полнота исчисления предикатов
** Свойства противоречивости
   Противоречивая теория – теория, в которой можно вывести p, ¬p.

   * Лемма: теория противоречива ↔ в ней выводится a & ¬a
     ← если выводится a & ¬a, то противоречива – очевидно
     через аксиомы &
     → если противоречива, то выводится a & ¬a
     a
     ¬a
     a → ¬a → (a & ¬a)

   Заметим, что всякое подмножество непротиворечивого множества формул
   Г непротиворечиво. Также, всякое бесконечное противоречивое
   множество содержит конечное противоречивое подмножество ввиду
   конечности вывода. Совместное множество – множество с моделью (все
   формулы множества верны в какой-либо интерпретации).
** Лемма 1: о дополнении непр. мн-ва до полного
   Покажем, что для всякого непротиворечивого множества Г замкнутых
   формул сигнатуры σ существует множество Г', являющееся к тому же
   полным, имеющее ту же сигнатуру и содержащее Г.

   Для не более чем счетных сигнатур будем добавлять недостающие
   формулы в Г - если есть формула a, добавим a или ¬a в зависимости
   от того, является ли Г∪a или Γ∪¬a противоречивым или нет (выберем
   непротиворечивый вариант). Одно всегда верно, потому что:
   1. Г∪a, Γ∪¬a противоречивы обе. Тогда Γ противоречиво.
   2. Г∪a, Γ∪¬a непротиворечивы обе. a → ¬a → a&¬a. →←

   Лемма Цорна гласит, что частично упор. мн-во, в котором
   каждая цепь имеет верхнюю грань, содержит максимальный
   элемент.

   Рассмотрим частично упорядоченное множество, где элемент --
   непротиворечивое множество, а отношение ≤ -- "быть
   подмножеством". Тогда в силу не более чем счетности любой цепи по
   предыдущему случаю каждая цепь имеет верхнюю границу. По лемме
   Цорна наше множество содержит максимальный элемент. Этот элемент
   полон (если нет, то можем в него добавить a или ¬a, значит есть
   что-то больше него).
** Условие о интерпретации непротиворечивого мн-ва
   Будем называть интерпретацией непротиворечивого множества формул
   функцию оценки, тождественно равную 1 на элементах из этого
   множества. Будем говорить, что Г ⊨ a, если она тождественна в любой
   модели Г.
** Лемма 2: если Г ⊢ a, то Г ⊨ a
   Механическая проверка аксиом, аналогичная таковой в корректности
   модели для ИВ.
** Лемма 3: если у Г есть модель, то Г непротиворечиво
   Пусть Г имеет модель, но противоречиво, тогда из Г
   выводится a, ¬a, по корректности Г ⊨ a, ¬a, но формула
   и ее отрицание не могут быть общезначиыми одновременно.
** Лемма 4: о модели бескванторного непротив. мн-ва формул
   Пусть Г -- полное непротиворечивое множество *бескванторных*
   формул. Тогда существует модель для Г.

   Построим модель структурной индукцией по формулам. Предметное
   множество -- строки, содержащие выражения.  То есть какое-нибудь
   f₁(c, b, f₅(c₅)) = "f₁(c, b, f₅(c₅))" Мы не хотим заниматься
   подсчетом, а предпочитаем оставлять то, что нужно вычислить как
   отдельную функцию. Рассмотрим формулу -- предикат. Его оценка
   истинна, если он принадлежит носителю; ложна, если его отрицание
   находится в носителе (в предметном множестве). Элементы всегда
   входят противоречиво (элемент не вдохит со своим отрицанием.
   Связки определим естественным образом.

   Докажем, что γ ∈ Γ <=> γ истинна  (Γ - предметное множество)
    * База: Если атомарная формула лежит в Г, то она истинна по опр.
      Если атомарная формула истинна, то лежит в Г.
    * Переход
      1) a & b
         если a & b лежит в Г, то оно истинно по определению.
         если [a & b] = 1
         1. [a & b] = И, покажем a & b ∈ Γ
            Пусть [a & b] = И, тогда по таблице истинности
            [a] = [b] = И, тогда a, b лежат в Г по предполож.
            тогда a → b → a & b лежит в модели
         2. [a & b] = Л, покажем !(a & b) ∈ Г
            a ложь или b ложь по таблице истинности. Пусть
            a ложь, тогда
            ¬a ∈ Г. (a & b) → ¬a, (a & b) → a, 9 акс.
      2) a V b
         1. [a V b] = И
            [а] = И, [b] = И, они лежат в множестве, a → a V b
         2. [a V b] = Л
            ¬a, ¬b лежат в множестве, тогда 9 акс.
      3) Аналогично
** Теорема Гёделя о полноте исчисления предикатов
   Γ - непротиворечивое множество формул, тогда Г имеет модель.
*** Построение Г*
    Нам нужно построить из нашего множества формул множество
    беcкванторных формул, для этого определим следующую операцию
    избавления от 1 квантора.  Построим новый язык, отличающийся от
    нашего контантами, там будут dᵢⱼ, где первый индекс - это
    поколение, второй – нумерационный.

    Возьмем непротиворечивое множество формул Γᵢ и пополним
    его, получив непротиворечивое множество формул Γᵢ₊₁, такое
    что Гᵢ ⊂ Γᵢ₊₁.

    Возьмем формулу γ ∈ Γᵢ.
    1. Не содержит кванторов. Ничего не делаем.
    2. γ = ∀x.a. Возьмем все константы, использующиеся в Γᵢ -
       это будут cᵢ и dₐⱼ, где a ≤ i, занумеруем их θ₁, θ₂,...
       и добавим формулы a₁=a[x:=θ₁],... к Γᵢ₊₁
    3. γ = ∃x.a. Возьмем новую константу dᵢ₊₁ⱼ и добавим a[x:=dᵢ₊₁,ⱼ]

    Заметим, что сами формулы с кванторами мы не выкидываем --
    ведь в будущем появятся новые формулы, и процесс для уже
    использованных кванторных формул нужно будет повторить.

    Покажем, что полученные множества остаются непротиворечивыми.
    Пусть Гᵢ непротиворечиво, а Γᵢ₊₁ противоречиво, тогда Γᵢ₊₁ ⊢ a&¬a.
    Выпишем конечное доказательство, найдем посылки, новые в Γᵢ₊₁,
    которых нету в Γᵢ, выпишем их и перекинем направо по теореме о
    дедукции:

    Гᵢ ⊢ γ₁ → γ₂ → γ₃ → ...→ γₙ → b&¬b

    Новые посылки у нас получаются только из пунктов 2 и 3.
    1. γ₁ = a[x:=θ] из ∀x.a
       ∀x.a → a[x:=θ]
       ∀x.a
       a[x:=θ]
       ...
       a[x:=θ]→(γ₂ → ...γₙ → b&¬b)
       γ₂ → ... → b&¬b
    2. γ₁ = a[x:=dᵢ₊₁,ₖ] из ∃x.a выберем переменную, не участвующую
       в выводе противоречия - z. заменим все вхождения dᵢ₊₁,ₖ
       в д-ве на z. поскольку dₖ - константа, мы можем делать такие
       замены. Поскольку z - константа, специально введенная
       для замены и раньше не встречавшаяся, то она отсутствует
       в γ₂,... + мы можем правильно выбрать b, чтобы она в нем
       отсутствовала. Значит мы можем применить правило вывода с ∃
       a[x:=z] → (γ₂ → ... → b&¬b)
       ∃z.a[x:=z] → ...             правило вывода
       ∃x.a                         из Γᵢ
       ∃z.a[x:=z]
       γ₂ → ... → b&¬b

    Возьмем Г₀ = Γ. Γ* = ∪Γᵢ. Г* также не противоречиво, потому что
    д-во использует конечное количество предположений, добавленных
    на каком-то шаге j максимум, значит множество Γⱼ тоже противоречиво,
    что невозможно по условию.
*** Дополненное бескванторное подмн-во Γ* - модель для Г
    Выделим в Г* бескванторное подмножество G.

    Пополним его по лемме 1 (там где лемма цорна, можем дополнить)
    модель сделаем из него по лемме о бескванторной модели. Покажем,
    что это модель для всего Г*, а значит и для Γ. Рассмотрим γ ∈ Γ*,
    покажем, что [γ] = И.
    * База. Формула не содержит кванторов. Истинность гарантируется
      леммой о бескванторном множестве.
    * Переход. Пусть G -- это модель для любой формулы из Γ* с r
      кванторами, покажем что она остается моделью для r+1 квантора.
      1. γ = ∀x.a
         Покажем, что формула истинна для любого t ∈ D.
         По построению подели есть такое θ, что t = "θ" (string).
         По построению Γ* начиная с шага p+1 мы добавляем формулы
         вида a[x:=k], где k - конструкция из констант и ф.симв.
         Также каждая константа (cᵢ или dᵢⱼ) из θ добавлена на
         некотором шаге sₖ. То есть будет шаг l=max(max(sₖ), p),
         на котором θ обретет смысл и в Γₗ₊₁ будет присутствовать
         a[x:=θ]. В формуле a на один квантор меньше, значит она
         истинна по предположению индукции.
      2. γ = ∃x.a По построению Г* как только добавили a к Гᵢ, так
         сразу в следующем мире Гᵢ₊₁ появляется a[x:=dᵢ₊₁,ₖ]. Значит
         формула истинна на значении "dᵢ₊₁,k", то есть истинна.
** Следствие – если ⊨a, то ⊢a
   * Пусть Г⊬a, тогда по полноте множества Г, Γ⊢¬a, но у Г есть
     модель, в которой Г⊨¬a. То есть Г⊭a.  Но Г по построению то же,
     что и модель теории, то есть все рассуждения Г ⊢ a равноценны в
     предикатах ⊢ a.
   * Пусть ⊬a, тогда пусть Γ={¬a}
     1. Г непротиворечиво
        Пусть Г противоречиво, значит ∀b Γ ⊢ b, Γ ⊢ ¬b;
        1. ¬a ⊢ b, ¬a ⊢ b;
        2. ¬a ⊢ a, ¬a ⊢ ¬a;
        3. ⊢ ¬a → a, ¬a → ¬a
        4. ⊢ (¬a → a) → (¬a → ¬a) → ¬¬a
        5. ⊢ ¬¬a → a
        6. ⊢ a          →← а недоказуемо по условию.
     2. Г подходит под условие теоремы Гёделя о полноти исчисления
        предикатов, то есть у Г есть модель. Тогда в ней оценка [¬a] =
        1, значит оценка [a] = 0, то есть ⊭a. Мы доказали
        мета-контрпозицию ⊬a => ⊭a.
* Ticket 7: ФА
** Структуры и модели, теория первого порядка
   Теория первого порядка - это формальная система с кванторами по
   функциональным символам, но не по предикатам. Рукомахательное
   определение – это фс с логикой первого порядка в основе, в которой
   абстрактные предикаты и функциональные символы определяются точно
   (а может такое определение даже лучше).

   Структура по ДГ:
   Структурой теории первого порядка мы назовем упорядоченную тройку
   <D, F, P>, где F — списки оценок для 0-местных, 1-местных и т.д.
   функций, и P = hP 0 , P 1 , ...i — списки оценок для 0-местных,
   1-местных и т.д. предикатов, D — предметное множество.

   Понятие структуры — развитие понятия оценки из исчисления предикатов.
   Но оно касается только нелогических составляющих теории; истинностные
   значения и оценки для связок по-прежнему определяются исчислением
   предикатов, лежащим в основе теории. Для получения оценки формулы
   нам нужно задать структуру, значения всех свободных индивидных
   переменных, и (естественным образом) вычислить результат.

   Структура по-моему:
   Все то же самое определение из ИВ. Мы просто забиваем на предикаты
   в ИВ (не определям их), расширяем нашу сигнатуру (добавляя конкретные
   предикаты и функциональные символы), определяем для нее интерпретацию.

   И как всегда,..
   Модель – это корректная структура (любое доказуемое утверждение должно
   быть в ней общезначимо).
** Аксиомы Пеано
   Множество N удовлетворяет аксиоматике Пеано, если:
   1. 0 ∈ N
   2. x ∈ N, succ(x) ∈ N
   3. ∄ x ∈ N : (S(x) = 0)
   4. (succ(a) = c & succ(b) = c) → a = b
   5. P(0) & ∀n.(P(n) → P(succ(n))) → ∀n.P(n)
** Формальная арифметика -- аксиомы, схемы, правила вывода
   Формальная арифметика - это теория первого порядка, у которой
   сигнатура определена как: (циферки, логические связки, алгебр.
   связки, '), а интерпретацию сейчас будем определять.
   Интерпретация определяет два множества - V, P - истинностные и
   предметные значения. На самом деле нет никакого множества P,
   мы определяем только V, потому что оно нужно для оценок. Все
   элементы, которые мы хотели бы видеть, выражаются в сигнатуре.
   Пусть множество V = {0, 1} по-прежнему.
   Определим оценки логических связок естественным образом.
   Определим алгебраические связки так:
   +(a, 0) = a
   +(a, b') = (a + b)'
   *(a, 0) = 0
   *(a, b') = a * b + a

   *Тут должно быть что-то на уровне док-ва 2+2=4*
*** Аксиомы
    1. a = b → a' = b'
    2. a = b → a = c → b = c
    3. a' = b' → a = b
    4. ¬(a' = 0)
    5. a + b' = (a + b)'
    6. a + 0 = a
    7. a * 0 = 0
    8. a * b' = a * b + a
    9. φ[x:=0] & ∀x.(φ → φ[x:=x']) → φ
**** a = a
     Тут цифры в кавычках - д-во на i-й строке
     a = b → a = c → b = c                акс а2
     ⊤                                    ваша любимая аксиома
     "1" → ⊤ → "1"
     ⊤ → "1"
     ⊤ → ∀a."1"
     ⊤ → ∀a∀b."1"
     ⊤ → ∀a∀b∀c."1"
     ∀a∀b∀c."1"                           MP
     ∀a∀b∀c.(a = b → a = c → b = c) →
     ∀b∀c.(a + 0 = b → a + 0 = c → b = c) схема по ∀
     ∀b∀c.(a + 0 = b → a + 0 = c → b = c) MP
     ∀c.(a + 0 = a → a + 0 = c → a = c)   схема ∀, MP
     a + 0 = a → a + 0 = a → a = a        схема ∀, MP
     a + 0 = a                            акс а6
     a → a                                2 MP
* Ticket 8: рекурс, Аккерман
** Рекурсивные функции
   Z(x) = 0
   N(x) = x + 1
   Uₙᵢ(x₁...xₙ) = xᵢ
   S<f, g₁...gₙ>(x₁...xₘ) = f(g₁(x₁...xₘ),...gₙ(x₁...xₘ))
   R<f, g>(x₁...xₙ, n) = if n = 0
   f(x₁...xₙ)
   else g(x₁...xₙ, n, R<f, g>(x₁...xₙ, n - 1))
   μ<f>(x₁...xₙ) - минимальное k, такое что f(x₁...xₙ, k) = 0

   Пример:
   a + b = R<U₁, S<N, U₃₃>>(a, b)
** Характеристическая функция и рекурсивное отношение
   * Характеристическая фукнция от выражения возвращает 1 если
   выражение истинно, 0 иначе.
   * Рекурсивное отношение - отношение, характеристическая функция
   которого рекурсивна.
** Аккерман не примитивно-рекурсивен, но рекурсивен (второе)
   i:   A(0, n) = n + 1
   ii:  A(m, 0) = A(m - 1, 1)
   iii: A(m, n) = A(m - 1, A(m, n - 1))

   A(2, 0) = A(1, 1) = A(0, A(1, 0)) = A(0, 2) = 3
*** A(m, n) ≥ 1
    A(m, n) определена только на натуральных числах,
    A(0, 0) = 1, A(1, 0) = A(0, 1) = 2, A(0, 1) = 2,
    все остальное еще больше
*** Лемма 1a: A(1, n) = n + 2
    A(1, n)
    = A(0, A(1, n - 1))
    = A(0, A(0, A(1, n - 2)))
    = A(0, A(0, A(0, ... A(1, 0))))
    = A(0, A(0, A(0, ... 2)))
    = n + 2 (n раз инкрементируем двойку)
*** Лемма 1b: A(2, n) = 2n + 3
    A(2, n)
    = A(1, A(1, ... A(2, 0)))
    = A(1, A(1, ... 3))
    = 2n + 3 (n раз к тройке прибавляем A(0, 1) = 2)
*** Лемма 2: A(m, n) ≥ n + 1
    В первом случае A ≥ n + 1 = n + 1
    Во втором A может перейти в первый случай, который работает
    хорошо, или в третий.
    В третьем случае мы можем получить A(0, n) если первый аргумент
    был нулем, тогда все ок, можем получить A(1, 0), тогда это второй
    случай, для него условие выполнено.
    Третий ссылается на второй, а второй на третий, но тут
    нет противоречия, потому что мы знаем, что функция Аккермана
    завершается.
*** Лемма 3а: A(m, n) < A(m, n + 1)
    индукция по m:
    * база
      A(0, n) = n + 1 < n + 2 = A(0, n + 1)
    * переход:
      A(k + 1, m) < A(k + 1, m) + 1
      ≤ A(k, A(k + 1, m)) (по лемме 2)
      ≤ A(k + 1, m + 1)   (iii)
*** Лемма 3b: A(m, n + 1) ≤ A(m + 1, n)
    индукция по n:
    * база
      A(m, 0 + 1) = A(m, 1) = A(m + 1, 0) (ii)
    * переход, предположение: A(m, j + 1) ≤ A(m + 1, j)
      по лемме 2 (j + 1) + 1 ≤ A(m, j + 1)
      A(m, (j + 1) + 1) ≤ A(m, A(m, j + 1)) (по монотонности)
      A(m, A(m, j + 1)) ≤ A(m, A(m + 1, j)) (по монотонности + предположение)
      A(m, (j + 1) + 1) ≤ A(m, A(m + 1, j)) = A(m + 1, j + 1) (iii)
*** Лемма 3с: A(m, n) < A(m + 1, n)
    A(m, n) < A(m, n + 1) ≤ A(m + 1, n) (3а, 3b)
*** Лемма 4: A(m₁, n) + A(m₂, n) < A(max(m₁, m₂) + 4, n)
    A(m₁, n) + A(m₂, n)
    ≤ A(max(m₁, m₂), n) + A(max(m₁, m₂), n)
    = 2 * A(max(m₁, m₂), n)
    < 2 * A(max(m₁, m₂), n) + 3
    = A(2, A(max(m₁, m₂), n))     лемма 1
    < A(2, A(max(m₁, m₂) + 3, n)) строгая монотоннасть по обоим арг.
    < A(max(m₁, m₂) + 2, A(max(m₁, m₂) + 3, n)) лемма 3с
    = A(max(m₁, m₂) + 3, n + 1)   (iii)
    ≤ A(max(m₁, m₂) + 4, n)       лемма 3b
*** Лемма 5: A(m, n) + n < A(m + 4, n)
    A(m, n) + n
    < A(m, n) + n + 1
    = A(n, m) + A(0, n)
    < A(m + 4, n)
*** Аккерманн не примитивно-рекурсивен
    Пусть f(n₁...nₖ) - примитивная рекурсинвная функция, k ≥ 0.
    ∃J:f(n₁...nₖ)<A(J, ∑(n₁,...nₖ))

    ]n~ = (n₁...nₖ)
    Индукция по рекурсивным функциям
    * База:
      f(n~) - N или Z или Uₖⱼ
      1. f(n~) = N, k = 1; Пусть J=1, по (i) и лемме 3c
         f(n) = N(n) = n + 1 = A(0, n) < A(1, n) = A(J, n) = A(J, ∑(n~))
      2. f(n~) = Z, k = 1;
         f(n) = 0 < A(J, n) (потому что A ≥ 1) = A(J, ∑(n~))
      3. f(n~) = Uₖⱼ; k = k; Пусть J=1
         f(n₁...nₖ) = Uₖⱼ(n₁...nₖ) = nⱼ
         Пусть nⱼ = 0, тогда f(n) = 0 < A(J, ∑(n~)) для любого нормального J
         Пусть nⱼ > 0, тогда f(n) = (nⱼ - 1) + 1 = A(0, nⱼ - 1) < A(1, n)
         = A(J, ∑(n~))
    * Переход
      1. Предположим, что f(n~) = S<h, g₁...gₘ>(n~) = h(g₁(n~),...gₘ(n~))
         По предположению индукции существует J₀ для h, J₁...Jₘ для g₁...gₘ.
         f(n~) = h(g₁(n~),..)
         < A(J₀, ∑{i=1..m}(n~))            по выбору J₀
         < A(J₀, ∑(A(Jᵢ, ∑(n~))))           по выбору Jᵢ и строгой монотонности
         // J* = max(J₁..Jₘ) + 4(m - 1)
         < A(J₀, A(J*, ∑(n~)))             по лемме 4 примененной m-1 раз
         < A(J₀, A(J*+1, ∑(n~)))           по монотонности
         ≤ A(J₀, A(max(J₀, J*) + 1, ∑(n~))) по монотонности
         ≤ A(max(J₀, J*) + 1, ∑(n~) + 1)   (iii)
         = A(max(J₀, J*) + 2, ∑(n~))       по лемме 3b
         Тогда пусть j=max(J₀, J*) + 2
      2. Пусть f(n~) = R<h,g>(n~)
         f(n₁...nₖ, 0) = h(n₁...nₖ)
         f(n₁...nₖ, m+1) = g(n₁...nₖ, m, f(n₁...nₖ, m))
         По предположению имеем J₀ (h), J₁ (g).
         ] J = max(J₀, J₁) + 4
         1) f(n~, 0)
            ≤ f(n~, 0) + ∑(n~)
            = h(n~) + ∑(n~)
            < A(J₀, ∑(n~)) + ∑(n~)
            < A(J₀ + 4, ∑(n~))                   по лемме 5
            < A(J, ∑(n~))                       по монотонности
            = A(J, ∑(n~) + 0)
         2) f(n~, k + 1)
            = g(n~, k, f(n~, k))
            < A(J₁, ∑(n~) + k + f(n~, k))        по выбору J₁
            < A(J₁, ∑(n~) + k + 1 + f(n~, k))    по монотонности
            = A(J₁, A(0, ∑(n~) + k) + f(n~, k))  (i)
            < A(J₁, A(0, ∑(n~) + k) + H(J, ∑(n~)+k)) по предположению
            < A(J₁, A(J, ∑(n~)+k)+A(J, ∑(n~) + k)) по монотонности (J > 0)
            = A(J₁, 2 * [A(J, ∑(n~) + k)])
            < A(J₁, 2 * [A(J, ∑(n~) + k)] + 3)
            = A(J₁, A(2, A(J, ∑(n~) + k)))        по лемме 1
            < A(J₁, A(J₁ + 1, A(J, ∑(n~) + k)))   по строгой монотонности (J₁ > 2)
            = A(J₁ + 1, A(J, ∑(n~) + k) + 1)      (iii)
            ≤ A(J₁ + 2, A(J, ∑(n~) + k))
            < A(J - 1, A(J, ∑(n~) + k))           по монот. J > max(..) + 4
            = A(J, ∑(n~) + (k + 1))               (iii), J != 0
*** Аккерманн рекурсивен
    Можем сказать, что он рекурсивный, потому что мы можем
    его написать на компьютере, а тьюринг выражается в рекурсивных функциях.
* Ticket 9: представимость
** Функции, их представимость
   Арифметическая функция - это отображение f: N₀ⁿ →
   N₀. Арифметическое отношение - это P ∈ N₀ⁿ. Если k ∈ N₀, то k~ =
   0'''''..., где количество штрихов есть k.
   * Арифметическое отношение R ∈ N₀ⁿ выразимо в ФА, если
     ∃a с n свободными переменными:
     a(x₁...xₙ), такая что
     1. Eсли R(k₁...kₙ), то ⊢ a(k₁~...kₙ~)
     2. Eсли ¬R(k₁..kₙ), то ⊢ ¬a(k₁~...kₙ~)
   * C_R - функция, равная 1, если R, и равная 0, если ¬R
   * ∃!y.φ(y) = ∃y.φ(y) & ∀a∀b(φ(a) & φ(b) → a = b)
   * f: N₀ⁿ → N₀ представима в ФА, если ∃a(x₁...xₙ₊₁), что
     ∀x₁...xₙ+₁:
     1. f(x₁...xₙ) = xₙ₊₁ <=> ⊢a(x₁~,...xₙ₊₁~)
     2. ∃!b(a(x₁~...xₙ~, b))
** Теорема о связи представимости и выразимости
   R выразимо <=> Cᵣ представимо
   → a выражает R
   (a → (xₙ₊₁=0')) & (¬a → (xₙ₊₁=0))
   представляет Cᵣ
   По выразимости R ⊢ a; тогда ⊤→a→⊤ => a→⊤
   По 10i, перенесенной к нам a → (¬a → ⊥)
   правило с единственностью вроде понятно (хотя руками помахал, да)
   ← Cᵣ представимо → R выразимо
   Пусть представлять Cᵣ будет
   a(x₁....xₙ,xₙ₊₁)
   Тогда определим, какая формула выражает R:
   a(...., 1)
   Из представимости:
     * ∃b.a(x₁...xₙ₊₁)
     * ∀x∀y(a(...x) & a(... y) → x = y)
     * если Cᵣ(x₁...xₙ) = 1, то ⊢ a(x₁...xₙ,1)
     * если Cᵣ(...) = 0, то ⊢ a(..,0)

   Докажем выводимость
     1. Покажем, что если R(x₁...xₙ), то ⊢ a(x₁...xₙ, 1)
        Из представимости прямо ровно.
     2. Покажем, что если ¬R(x₁....xₙ), то ⊢ ¬a(x₁...xₙ, 1)
        по единственности

        ∀x∀y(a(x₁...xₙ, x) & a(x₁...xₙ, y) → x = y)
        a(x₁...xₙ, 0) & a(x₁...xₙ, 1) → (0 = 1) (спустя две акс. и 2 MP)
        дедукцию
        a(x₁...xₙ, 0) & a(x₁...xₙ, 1) ⊢ ⊥
        a(x₁...xₙ, 0) & a(x₁...xₙ, 1) → a(x₁...xₙ, 0)
        a(x₁...xₙ, 0)
        ¬a(x₁...xₙ, 0)                          по представимости
        a(x₁...xₙ, 0) → (¬a(x₁...xₙ, 0) → ¬a(x₁...xₙ, 1)) (10i в ИИВ, доказуема в предикатах)
        ¬a(x₁...xₙ, 1)
        хотим ¬a(x₁...xₙ, 1)
** beta-функция Гёделя, китайская теорема об остатках
   β(b,c,i) = b % (1 + c(1 + i)),
   где %(a, b) = d, ∀m.(d + m * b = a), m≥0, 0≤d≤b
*** Китайская теорема об остатках
    n₁...nₖ - попарно взаимно простые инты
    r₁...rₖ - любые целые, что 0 ≤ rᵢ < nᵢ
    ∀i∃b  rᵢ = b % nₖ
*** Гёделева Г-последовательность
    Гᵢ = (i + 1) * c + 1
    Γ(c) = 1*c + 1, 2*c + 1, 3*c + 1,...(n+1)*c + 1

    Докажем, что Г(c) подходит на роль n₁...nₖ в китайской
    теореме об остатках. Выделим последовательность размера
    n: k₁...kₙ.
    Чтобы это выполнялось возьмем c = (max(k₁...kₙ))!
**** В Г любые два элемента попарно взаимно простые
     Пусть Γᵢ ⋮ Γⱼ имеют общий делитель p > 1. Мы можем его разложить
     на простые множители и взять какой-нибудь простой (любое число
     раскладывается на простые множители).
     Тогда (Γᵢ - Γⱼ) ⋮ p, (c * (i - j)) ⋮ p. Заметим, что ¬(c ⋮ p),
     потому что иначе Γᵢ = 1 + c * (i + 1) ⋮ p и c * (i + 1) ⋮ p,
     а они отличаются на единицу. Тогда (i - j) ⋮ p, но c = m! m > n,
     а i - j < n, значит c ⋮ p. →←
**** Каждое kᵢ < Гᵢ
     kᵢ ≤ c < 1 + c * (i + 1) = Γᵢ
*** Лемма о β-функции
    Увидим, что β(b,c,i) считает остаток от деления b на
    (i + 1) * c + 1 - элемент Геделевой последовательности.
    * <a₀...aₙ>∈N → ∃b∃c(aₖ=β(b,i,c)) - β-функция кодирует
      последовательность натуральных чисел и может
      доставать по индексу i

      a₀...aₙ  - последовательность натуральных чисел
      тогда существует такое c, что Г = 1*c+1, 2*c+1,...
      если c ≥ max(a₀...aₙ), то aₖ < (i+1)*c+1
      Но по свойству Г элементы попарно взаимно просты
      тогда сравнения
      a₀ % (0+1)*c+1
      a₁ % (1+1)*c+1
      .............
      aₙ % (n+1)*c+1
      имеют общее решение b по китайской теореме об остатках
      тогда aᵢ = b % (i+1)*c + 1
      но это и есть β-функция
      aᵢ = β(b,c,i)
*** Представимость β-функции Гёделя в ФА
    β-функция представима в ФА отношением
    B(b,c,i,d) = ∃q((b = q * (1 + c * (i + 1)) + d) & (d < 1 + c * (i + 1)))
    Пусть 1 + c * (i + 1) = z
    Докажем условия представимости:
    1. Эквивалентность
       1) β(b,c,i) = d, тогда ⊢ B(b,c,i,d)
          b = z * (1 + c * (i + 1))    (это и следующее - из леммы о β) P
          d < 1 + c * (i + 1)                                           Q
          P → Q → P & Q
          P & Q
          P & Q → ∃q.(P & Q) [z:= q]
          ∃q.(P & Q)
       2) Пусть ⊢ B(b,c,i,d), тогда
          ∃q.(P & Q)
          подберем такое q (по лемме)
          P & Q → P
          P & Q → Q
          P
          Q
          значит β(b,c,i) = d
    2. Единственность
       Следует из леммы.
** Теорема о представимости рекурсивных функций Z, N, U
   1. Z
      Z(a, b) = (b = 0)
      * Z(a) = b верно, тогда b = 0
        b = 0
      * (b = 0)
        b = 0
        тогда Z(0) = 0, все ок
      * ∃y.φ(y) & ∀a∀b(φ(a) & φ(b) → a = b)
        Тоже как-то несложно
   2. N
      N(a, b) = (a = b')
      * N(a) = b, тогда a = b'
        a = b'
      * a = b', тогда
        N(a) = b
      * Третье не хочу
   3. Uₙᵢ
      Uₙᵢ(x₁...xₙ) = (x₁ = x₁) & (x₂ = x₂) & ... & (xₙ₊₁ = xᵢ)
      * U(..) = xᵢ, тогда xₙ₊₁ = x₁
        x₁ = x₁ доказывается
        ...
        xₙ = xₙ доказывается
        xₙ₊₁ = x₁ по условию
        объединяем все &
      * (x₁ = x₁) & ....
        вытаскиваем каждый элемент и тогда видим, что
        проекция делает ровно то, что должна.
      * ∃q.(xₙ₊₁ = q)
        ХЗ
      * ∀a∀b(x(...a)&x(....b) → a = b)
        Для конкретных a, b обявляем a = b - ⊤, тогда выводим
        из него конъюнкцию и навешиваем два квантора
** Теорема о представимости S
   Eсли f и g₁...gₙ представимы, то S<f, g₁...gₙ> представима
   Пусть F, G₁...Gₙ представляют их.
   S(a₁...aₘ, b) = ∃b₁...∃bₙ(G₁(a₁...aₙ, b₁) & ... & Gn(a₁...aₘ, bₙ)
   & F(b₁...bₙ, b))
   * Пусть S(a₁...aₙ) = b, тогда существуют такие b₁...bₙ, что #каждый аргумент#
     Поскольку f,g₁...gₙ представимы, то доказуемы по представимости
     f(b₁...bₙ, b)
     g₁(a₁...aₙ, b₁)
     ...
     gₙ(a₁...aₙ, bₙ)
     g₁ & g₂ & ... & gₙ & f    объединили &     "P"
     "P" → ∃b₁."P[b₁:=b₁]" + MP
     ...
     Ну и навесили кванторы, да.
   * Пусть верна формула с кванторами. Тогда она и есть уже то, что надо
   * не могу, да и вообще нигде это свойство не доказывается
** Теорема о представимости R
   Пусть f, g представимы F, G. Тогда R<f,g> представима.
   f: Nⁿ→N, g:Nⁿ⁺²→N
   r(x₁...xₙ, k, a) =
      ∃b∃c(
           ∃k(β(b, c, 0, k) & φ(x₁...xₙ, k))
           & B(b, c, xₙ₊₁, a)
           & ∀k(k<xₙ₊₁ → ∃d∃e(B(b,c,k,d)&B(b,c,k',e)&G(x₁...xₙ,k,d,e))))
   Единственная возможность осознать -- внимательно прочесть формулу.
   Тут β-функция используется в качестве функии отображения нашего шага
   вычисления рекурсии в результат, типа
   0 - F(...)
   1 - G(...)
   ...
   n - G(...)
** Теорема о представимости μ
   f: Nⁿ⁺¹→N представима F, тогда μ<f> представима M
   Μ<F>(x₁...xₙ₊₁) = F(x₁...xₙ, xₙ₊₁, 0) & ∀y((y < xₙ₊₁) → ¬F(x₁...xₙ, y, 0))
   * μ<f>(x₁...xₙ) = xₙ₊₁, тогда xₙ₊₁ - минимальное k, такое что f(x₁..xₙ,k) = 0
     то есть имеем
     F(x₁...xₙ, xₙ₊₁, 0)
     ∀x.(k < x → ¬F(x₁...xₙ, k, 0))
     Просто объединим конъюнкцией
   * обратно ей же и разъединим
* Ticket 10: Тьюринг
** Арифметические отношения, их выразимость
   * Арифметическое отношение R ∈ N₀ⁿ выразимо в ФА, если
     ∃a с n свободными переменными:
     a(x₁...xₙ), такая что
     1. Eсли R(k₁...kₙ), то ⊢ a(k₁~...kₙ~)
     2. Eсли ¬R(k₁..kₙ), то ⊢ ¬a(k₁~...kₙ~)
** Гёделева нумерация
   | a   |             `a | описание                              |
   |-----+----------------+---------------------------------------|
   | (   |              3 |                                       |
   | )   |              5 |                                       |
   | ,   |              7 |                                       |
   | ¬   |              9 |                                       |
   | →   |             11 |                                       |
   | V   |             13 |                                       |
   | &   |             15 |                                       |
   | ∀   |             17 |                                       |
   | ∃   |             19 |                                       |
   | xₖ  |     21 + 6 * k | переменные                            |
   | fⁿₖ | 23 + 6 *ᵏ * 3ⁿ | n-местные функцион. символы (', +, *) |
   | Pⁿₖ | 25 + 6 *ᵏ * 3ⁿ | n-местные предикаты (=)               |
   |-----+----------------+---------------------------------------|

   Последовательность значков будем составлять так:
   a₁...aₙ - наши простые числа, соответствующие char'ам, тогда
   p₁^(a₁) * p₂^(a₂),...pₙ^(aₙ) - геделев нумерал стринга, составленного
   из чаров.

   Если a - выражение, то `a - выражение в Геделевой форме (на
   практике пишут квадратные скобочки без нижних их половинок)
   Тогда если a - выражение, `a~ - это элемент предметного множества
   ФА, соответствующий нолику с количеством черточек, равным `a.

   Доказательство - это последовательность простых чисел, возведенная
   в геделевы нумералы выражений, являющихся составляющими док-ва, по
   порядку. Аналогично с составлением строки из символов.

   Тогда определим следующие функции операций с нумералами:
   * plog(a, b) = max n : a % bⁿ = 0
     Иногда вместо b стоит P_b, где P_b - простое число с индексом b.
     Функция берет геделев нумерал и достает у него i-й элем. последов.
   * len = max n : a % pₙ
     Возвращает длину строки\д-ва
   * s@t = p₁^(plog(s, 1)) * ... * pₗₑₙ₍ₛ₎^(plog(s, len(s))) *
     pₗₑₙ₍ₛ₎₊₁^(plog(t, 1)) * ... * pₗₑₙ₍ₛ₎₊ₗₑₙ₍ₜ₎^(plog(t, len(t)))
     Конкатенация строк
** Машина Тьюринга
   Машина тьюринга состоит из ленты, головки, регистра состояния и конечной
   таблицы состояний
   Более формально, это 7-кортеж: <Q, Γ, b, ∑, δ, q₀, F>
   Конечный список состояний, конечный алфавит, пустой символ из алфавита,
   символы, которые мы можем писать (из Γ \ b), функция таблицы состояний,
   начальное состояние из Q, конечное состояние из Q.
   * Лента - бесконечный двусвязный список, в каждой ячейке которого
     содержится символ из конечного алфавита, в котором также есть
     пустой символ (тут и далее  ), которым изначально заполнена вся
     лента
   * Головка может находиться над элементом, писать в него и читать из
     него символ. Может двигаться влево-вправо (или двигать ленту, неважно)
   * Регистр состояния хранит состояние - элемент из конечного множества
     состояний машины. Есть особые состояния - стартовое и конечные.
   * Таблица состяний - таблица, хранящая данные о функции смены
     состояния - foo: Γ × Q → Γ × Q × {left, this, right}.
     Функция берет текущее состояние, читает символ на головке, потом
     получает тройку, пишет новый символ, перемещается по третьему
     элементу, выставляет новое состояние. Если состояние конечное, то
     она останавливается.
   Мы будем придерживаться нотации <_, _,  , _, _, S, F>.
** Проблема останова
   Дано описание процедуры и входные данные. Функция P(a, b) определяет,
   остановится ли a на входных данных b. Существует ли P?
   * Проблема останова неразрешима на машине Тьюринга:
     Пусть P существует.
     Тогда S(x) = P(x, x) остановится ли функция на своем же коде
     MyProg(x) = if S(x) then while(true){} else 1
     Рассмотрим MyProg(`MyProg)
     Если оно остановится, то первое условие выполнено, тогда оно не остановится
     И наоборот.
     Значит, P не существует.
** Выводимость и рек. функции - Тьюринг
*** Выражение машин Тьюринга через рекурсивные функции
    Мы хотим доказать, что если у нас есть какая-нибудь процедура, которую
    можно выразить в Тьюринге, то мы можем ее сделать и в формальной арифметике
    (рекурсивные функции представимы).
    Введем обозначение <st,tape,pos> = 2^(st)*3^(tape)*5^(pos)
    Такая тройка -- основная характеристика машины в данный момент.
    Будем называеть ее текущим полным состоянием, например.
    st, tape, pos - геделевы нумералы, st - нумерал из 1 элемента с состоянием,
    tape - string, обозначающий ленту (бесконечные   слева и справа не входят),
    pos - позиция в ленте.
    * p: <st, a> → <st, a, dir>
      принимает <st, a>, декодит, лезет в δ машины тьюринга, достает
      новые значения, делает из них <,,>, отдает.
    * t: <st> → 0 | 1
      Определяет, терминально ли наше состояние (0 если терминально)
    * ε - пустой символ (у нас  )
    * pb, pc кодируют β-функцией последовательность инпутов
      в последовательность аутпутов. β(p_b, p_c, x) = p(x)
    * tb, tc аналогично кодируют t
    * R<f,g>(<s_st, s_tape, s_pos>, ε, pb, pc, tb, tc, y)
      Запускает машину Тьюринга от стартового состояния, заранее
      говоря ей, сколько шагов (y) она должна сделать.
      Возвращает тройку <st, tape, pos>
    * Определим f, g
      1. Дополнительные функции
         * os(prev) = plog(prev, 1)
           Текущее состояние
         * ot(prev) = plog(prev, 2)
           Лента
         * op(prev) = plog(prev, 3)
           Позиция головки в ленте
         * nextstate(pb, pc, prev) = β(pb, pc, 2^(os(prev)) * 3^(plog(ot(prev), op(prev)))
           Реализует функцию p
         * st(pb, pc, prev) = plog(nextstate(pb, pc, prev), 1)
           Новое состояние.
         * sym(pb, pc, prev) = plog(nextstate(pb, pc, prev), 2)
           Символ который нужно писать
         * dir(pb, pc, prev) = plog(nextstate(pb, pc, prev), 3)
           Направление для перехода головки
         * repl(pb, pc, prev) = (ot(prev) / (P_op)^(plog(ot(..), op(..)))) * (P_op)^sym(..)
           Возвращает ленту, в которой удален символ в позиции op,
           и добавлен новый символ в эту же позицию.
      2. f - возвращает полное состояние машины
         f(<start_state>, ε, pb, pc, tb, tc) = <start_state>
      3. g - возвращает новое полное состояние из машины после перехода
         (пометка: 0 - nothing, 1 - right, 2 - left
         все фукнции вызываются с аргументом prev, <start_state> не используется)
         g(<start_state>, ε, pb, pc, tb, tc, y, prev) =
         |--------------------------+--------------------------+------------|
         | Condition                | Result                   | Desrc      |
         |--------------------------+--------------------------+------------|
         | dir = 0                  | <st, repl, op>           | nothing    |
         | dir = 1 & len(repl) = op | <st, repl@2^(ε), op + 1> | tape end   |
         | dir = 1                  | <st, repl, op + 1>       | move right |
         | dir = 2 & op = 0         | <st, 2^(ε)@repl, op - 1> | tape start |
         | dir = 2                  | <st, repl, op - 1>       | move left  |
         |--------------------------+--------------------------+------------|

    * Определим steps - функцию, определяющую необх. кол-во шагов
      steps(<start_state>, ε, pb, pc, tb, tc) =
      μ<β(tb, tc, plog(R<f,g>, 1))>(<start_state>, ε, pb, pc, tb, tc)
      Она найдет такое минимальное к, что состояние plog(R<f, g>(args, k), 1) терминально.
*** Выражение программы по проверке доказательства в машине тьюринга
    * Emulate(input, prog) = plog(R<f,g>(<`S, input, 0>,  , pb, pc, tb, tc, steps(-//-)), 1) == F
      Функция проверяет, правда ли получившееся терминальное состояние - ок.
      Можем давать программу такую, что она заканчивается в терминальном F(inish)
      или в терминальном FAIL
      Дает в качестве аргумента функцию перехода, pb, pc выражают prog
    * Proof(term, proof) = Emulate(proof, MY_PROOFCHECKER) && (plog(proof, len(proof)) = term)
      Проверяет, что доказательство p заканчивается корректно и его последний
      элемент - то, что мы доказываем.
    * Любая представимая в ФА ф-я является рекурсивной
      Пусть f представима
      Пусть f(x₁...xₙ) = b, тогда ⊢ φ(x₁~...xₙ~, b~)
      Всегда можно построить рекурсивную функцию G_φ(x₁...xₙ, b, p),
      утверждающую, что p - гёделев номер вывода предиката φ(x₁~...xₙ~, b~)
      Мы делаем это обычным перебором чисел, проверяем вывод нашей
      программой из домашнего задания, выраженную в тьюринге, а потом в
      рекурсивных функциях.
      Тогда f в рекурсивных функциях выражается так:
      f(x₁...xₙ) = plog(μ<S<G_φ, Uₙ₊₁,₁,... Uₙ₊₁,ₙ,
      plog(Uₙ₊₁,ₙ₊₁, 1),
      plog(Uₙ₊₁,ₙ₊₁, 2)>>(x₁...xₙ), 1)
      Такая функция берет plog(1) от первого такого минимального геделева
      номера k (геделева пара из двух элементов - <b, p>)), что
      S<G_φ, U....>(x₁...xₙ, k) = 0. Это значит, что
      G_φ(x₁...xₙ, plog(k, 1), plog(k, 2)) = 0, это значит, что
      G_φ(x₁...xₙ, b, p) = 0, то есть p - вывод φ(x₁~...xₙ~, b~).
      Этот геделев номер - b
* Ticket 11: 1т о неполноте
** Непротиворечивость, ω-непротиворечивость
   * Теория непротиворечива, если в ней нельзя вывести
     одновременно a и ¬a (что аналогично невозможности
     вывести a&¬a).
   * Теория ω-непротиворечива, если из ∀φ(x) ⊢φ(x~) следует
     ⊬ ∃p¬φ(p). Проще говоря, если мы взяли
     формулу, то невозможно вывести одновременно ∃x¬A(x)
     и A(0), A(1), ...
   * Лемма о w-# и обычной непротиворечивости
     Если теория w-непротиворечива, то она непротиворечива
     φ = x=x → x=x
     Такая формула очевидно доказуема (A → A)
     ⊢φ[x:=k] k ∈ N₀
     Но недоказуемо ∃x¬(x=x→x=x)
     А в противоречивой теории доказуемо все
** Прервая теорема о неполноте
   Определим отношение W₁(x, p), истинное тогда и только тогда,
   когда x - геделев номер формулы φ с единственным свободным
   аргументом x, а p - геделев номер доказательства φ("φ"). Это
   отношение выразимо в ФA, потому что мы просто пихаем это в наш
   Proof, а его мы выразили через рекурсивные функции, а они
   представимы.
   Пусть его выражает w₁(x, p);
   Рассмотрим формулу σ = ∀p¬w₁(x, p) - для любого доказательства
   оно не является доказательством самоприменения φ, то есть
   самоприменение φ недоказуемо.
   То есть если σ(`a~) истинно, то a(`a~) недоказуемо.
   В нашем случае если σ(`a~) истинно, то σ(`σ~) недоказуемо.
   1. Если формальная арифметика непротиворечива, то недоказуемо σ(`σ~)
      1) Пусть ⊢ σ(`σ~), тогда найдется геделев номер ее док-ва p,
         тогда W₁(`σ, p), то есть ⊢ w₁(`σ~, p~).
      2) С другой стороны,
         ⊢ σ(`σ~)
         ⊢ ∀p¬w₁('σ~, p)
         ∀p¬w₁(`σ~, p) → ¬w₁(`σ~, p~)
         ¬w₁(`σ~, p~)
         Тогда ФА противоречива.
   2. Если формальная арифметика w-непротиворечива, то недоказуемо ¬σ(`σ~)
      Пусть ⊢ ¬σ(`σ~), то есть ⊢ ¬∀p¬w₁(`σ~, p), что значит ∃p.w₁(`σ~, p)
      Найдется такой q, что ⊢ w₁(`σ~, q~), потому что если бы не нашелся,
      это бы значило доказуемость для каждого q ¬w₁(`σ~, q~), тогда по
      ω-непротиворечивости было бы не доказуемо ∃p¬¬w₁(`σ~, p)
      То q, что мы нашли - это номер доказательства  σ(`σ~), что и
      утверждает выражение ⊢ w₁(`σ~, q~). Но мы предполагали, что ⊢ ¬σ(`σ~).
      Противоречие.

   Нормальное доказательство общезначимости:
   Я не знаю, зачем нам второй пункт, но из первого следует, что если
   наша теория w-непротиворечива, то она непротиворечива (по лемме выше),
   значит в ней недоказуемо σ(`σ~), то есть ∀p¬w₁(`σ~, p), то есть
   по корректности последнее выражение И, но это и есть в точности определение
   σ(`σ~).

   Ненормальное д-во общезначимости:
   Итого мы доказали, что если формальная арифметика ω-непротиворечива,
   то в ней не доказуемо ни σ(`σ~) ни ¬σ(`σ~). Одно из них точно тавтология
   (в формуле нет свободных переменных). Тогда ФА неполна при условии
   ω-непротиворечивости.

   Другое доказательство общезначимости:
   ¬σ(`σ~) недоказуема
   [σ(`σ~)] = [∀p¬w₁(`σ~, p)] =
   1. И если [¬w₁(`σ~, a)] = И для какого-то а
   2. Л иначе

   Это значит, что
   И если [w₁(`σ~, a)] = Л
   [w₁(`σ~, a)] = Л, докажем от противного
   Пусть [σ(`σ~)] = Л,
   [∀p¬w₁(`σ~, p)] = Л
   [¬∀p¬w₁(`σ~, p)] = И
   [∃p.w₁(`σ~, p)] = И
   [w₁(`σ~, a)] = И для какого-то а
   то есть a доказывает σ(`σ~)
   ???

   тогда по определению w₁ существует
   доказательство σ(`σ~),
** Пример w-противоречивой, но непротиворечивой теории (при усл. непрот. ФА)
   Добавим в ФА аксиому Г: ¬σ(`σ~)
   Тогда по контрпозиции 1п2 она w-противоречива.
   Если бы мы могли доказать противоречивость нашей системы, то
   ФА была бы противоречива, тогда хз
   ¬σ(`σ~) ⊢ σ(`σ~)&¬σ(`σ~)
   ⊢ σ(`σ~)
   Но мы предположили что ¬σ(`σ~)
** Форма Россера
   Если формальная арифметика непротиворечива, то в ней найдется
   такая формула φ, что ⊬φ и ⊬¬φ
* Ticket 12: 2т о неполноте
** Consis, Условия выводимости Гильберта-Бернайса
   Определим Consis как утверждение, показывающее
   непротиворечивость ФА - отсутствие φ : ⊢ φ, ¬φ. Поскольку
   в противоречивой теории выводится что угодно, возьмем что-то
   недоказуемое, типа 1=0.
   Consis = ∀p(¬Proof('(1=0)~, p))

   Определим отношение Sub(a, b, c) истинно, если выполнено одно из
   двух:
   1. a, b геделевы номера; c = `a[x:=b]
   2. a или b не геделев номер и c = 0

   Пусть Sub(a, b, c) выражает τ(a, b, c)

   * Лемма о самоприменении
     a(x) - формула, тогда ∃b такой что
     1. ⊢ a(`b~) → b
     2. ⊢ b → a(`b~)

     b₀(x) = ∀t(τ(x, x, t) → a(t))
     b = b₀(`b₀~)
     1. a(`b~) ⊢ a(`b~)
        a(`b~) ⊢ τ(`b₀~, `b₀~, `b~) → a(`b~)    акс 1 + MP
        a(`b~) ⊢ ⊤ → (τ(`b₀~, `b₀~, `b~) → a(`b~))
        a(`b~) ⊢ ⊤ → ∀t(τ(`b₀~, `b₀~, t) → a(t))
        a(`b~) ⊢ ∀t(τ(`b₀~, `b₀~, t) → a(t))
        a(`b~) ⊢ b
     3. b ⊢ ∀t(τ(`b₀~, `b₀~, t) → a(t))    тут почти a ⊢ a написано
        b ⊢ τ(`b₀~, `b₀~, `b~)             по выразимости
        b ⊢ τ(`b₀~, `b₀~, `b~) → a(`b~)    сняли квантор с 1
        b → a(`b~)

   * Условия Гильберта-Бернайса
   Пусть πg(x, p) выражает Proof(x, p)
   πr(x) = ∃t πg(x, t) тогда если
   1. ⊢ a , то ⊢πr(`a~)
   2. ⊢ πr(`a~) → πr(`πr(`a~)~)
   3. ⊢ πr(`a~) → πr(`(a → b)~) → πr(`b~)
** Вторая теорема о неполноте
*** Рукомашеское доказательство без условий Г-Б
    * Если арифметика непротиворечива, в ней нет д-ва Consis
      рассмотрим Consis → σ(`σ~).
      Тогда если Consis доказуемо, то σ(`σ~) недоказуемо.
      То есть это формулировка 1.1 Гёделя о неполноте.
      Тогда если у нас будет Consis, мы сможем доказать
      σ(`σ), тогда 1.1 фейлится. Значит Consis недоказуемо.

    * Доказательство того, что Consis недостаточно формален
      Заменим Consis в д-ве на
      Proof1(a, x) = Proof(a, x)&¬Proof(`(1=0),x)
      Consis1 = ∀x¬Proof1(`(1=0),x)
      Если арифметика непротиворечива, то Proof1(a, x) = Proof(a, x)
      Если арифметика противоречива, то Consis1 доказуема как и все
      остальное.
      Ну давайте менять.

      Поменяли. Смотрим. хехехе, давайте докажем Consis1:
      ¬(π(x) & ¬π(x))              доказуемо в ИВ
      ⊤
      ⊤ → ¬(π(x) & ¬π(x))          1 акс, MP
      ¬(π(x) & ¬π(x))
      ∀x(¬(π(x) & ¬π(x)))

      Тогда выходит, что мы можем доказать противоречивость арифметики.
      Но это не так, бага вот в чем:
      Замена consis на consis1 неоправдана - в consis1 есть
      формула 1=0, на которой ее результат не вычисляется, а
      постулируется.
      Чтобы выражать Consis абстрактно, существуют условия выводимости
      Гильберта-Бернайса.

      Докажем, что consis1 не удовлетворяет 3 свойству Г-Б
      Пусть Proof1(x,p) выражает π1.
      ⊢ π1(`a~) → π1(`a→b~) → π1(`b~) оценим при a=(2=0), b=(1=0)
      ?       → (   true  →  false)
      ?       → false
      Если эта формула верна, то ⊢ π1(`a~)
      Тогда если π1(`a~), то Proof(2=0, x)&¬Proof(`1=0, x) = И
      Это значит что теория противоречива, потому что в ней выводимо 2=0,
      но она непротиворечива, потому что недоказуемо 1=0. →←
*** Доказательство 2 теоремы Гёделя о неполноте
    Пусть π удовлетворяет условиям Г-Б
    Consis = ¬π(1=0)
    ФА непротиворечива
    Тогда ⊬ Consis

    1. По лемме о самоприменении
       1. ¬π(γ) → γ
       2. γ → ¬π(γ)
       3. ¬γ → π(γ)                            контрпозиция
       4. π(γ) → ¬γ
    2. π(γ) → π(¬γ)
       1. π(γ) ⊢ π(`π(γ)~)                     ГБ2
       2. ⊢ π(π(γ) → ¬γ)                       ГБ1 от 1.4
       3. ⊢ π(π(γ)) → π(π(γ) → ¬γ) → π(¬(γ))   ГБ3
       4. π(γ) ⊢ π(¬γ)                         2MP (2.1, 2.2)
    3. ⊢ π(α → β → γ) and ⊢ π(α) → π(β) => ⊢ π(α) → π(γ)
       1. π(α → β → γ) → π(α) → π(b → γ)        ГБ3
       2. π(β → γ) → π(β) → π(γ)                ГБ3
       3. π(α) → π(β → γ)                       MP 1, given
       4. π(α) → π(β)                           given
       5. π(α) → π(γ)                           занести под дедукцию, ГБ3
    4. ⊢ π(γ) → π(1=0)
       1. γ → ¬γ → (1=0)                        10i в ИИВ, выводима в предикатах
       2. ⊢ π(γ → ¬γ → (1=0))                   ГБ1
       3. π(γ) → π(¬γ)                          2
       4. ⊢ π(γ) → π(1=0)                       MP 4.2 4.3
    5. ⊬ Consis
       ⊢ ¬π(1=0) → ¬π(γ)                        контрапозиция 4
       ⊢ Consis → ¬π(γ)                         the same
       ] ⊢ Consis, тогда ⊢ ¬π(γ)
       ⊢ ¬π(γ) → γ => ⊢ γ => ⊢ π(γ)            1.1, ГБ1
       ⊢ ¬π(γ), ⊢ π(γ)  →←
* Ticket 13: ТМ
** Теория множеств
   Значит это такая теория первого порядка.
   В сигнатуре модели есть один пред.символ - ∈
   Добавляем связку a ←→ b = (a → b) & (b → a)
   σ ∈ Θ => ∀x(x ∈ σ → x ∈ Θ)
   σ = Θ => σ ∈ Θ & Θ ∈ σ
   ∅ : ∀x(¬x ∈ ∅)
   x ∩ y = z, тогда ∀t(t ∈ z ←→ t ∈ x & t ∈ y)
   Dj(x) ∀a∀b(a ∈ x & b ∈ x & a ≠ b → a ∩ b = ∅)
   X(a) - мн-во всех x пересекающихся ровно в одном эл-те с каждым из а
   и содержащих элементы из ∪a.
   X({{1, 2}, {2', 3}}) = {{2, 3}, {1, 2'}}
*** Если существует мн-во, то существует пустое мн-во
    Аксиома выделения:
    ∀x∃b∀y(y ∈ b ←→ (y ∈ x & φ(y)))
    Возьмем наше существующее мн-во x
    ∃b∀y(y ∈ b ←→ (y ∈ x & φ(y)))
    Пусть φ(y) = ⊥
    тогда подставим ∅ вместо b:
    ∀y(y ∈ ∅ ←→ (y ∈ x & ⊥))
    Это выполняется вроде.
*** Если x, то найдется {x}
    ∀x∃{x}∀y(y ∈ {x} → y = x)
    1. Пусть x ≠ ∅
       {x} = {y | y ∈ {x, y} & y ≠ ∅}
       по аксиоме объединения ∃p∀y(y ∈ p ←→ ∃s(y ∈ s & s ∈ x))
       ∀y(y ∈ {x, ∅} ←→ ∃s(y ∈ s & s ∈ x))

       или по аксиоме пары
       ∃p(x ∈ p & ∅ ∈ p & ∀z(z ∈ p → (x = z V y = z)))
       x ∈ {x, ∅} & ∅ ∈ {x, ∅} & ∀z(z ∈ {x, ∅} → ...}

       ДГ руками помахал тут, ну и я помахаю по причине
       отсутствия времени доказывать

       А, нет, вот, кажется:
       По аксиоме степени ∀x∃{x, ∅}∀y(y ∈ {x, ∅} ←→ y ∈ x)
       ∀x∃{x, ∅}∀y((y ∈ {x, ∅} → y ∈ x)&(y ∈ x → y ∈ {x, ∅}))
       ¬y ∈ ∅, значит (y ∈ x → y ∈ x) = ⊤
       ∀x∃{x, ∅}∀y((y ∈ {x, ∅} → y ∈ x)&⊤)
       ∀x∃{x, ∅}∀y(y ∈ {x, ∅} → y = x)   более слабое условие
    2. x = ∅
       P(∅) = {∅}
*** ∃!x(∀y.¬(y ∈ x))
    ∃x(∀y.¬(y ∈ x)) & ∀a∀b((∀y.¬(y ∈ a)) & (∀y.¬(y ∈ b)) → a = b)
    Первое по определению пустого множества и аксиоме выделения с ⊥
    ∀y.(¬y ∈ {}) & ∀y.(¬y ∈ {}) → ∀p((p∈x → p∈y) & (p∈y → p∈x))
    Второе как-то через ∅₁ ∈ ∅₂ и обратное включение
    На основании того, что мы подставляем наши пустые множества, импликация
    вырождается в ⊤ → ⊤
*** x ∩ y существует
    по теореме выделения
    ∀x∃b∀y(y ∈ b ←→ (y ∈ x & φ(y)))
    ∀y(y ∈ x ∩ y ←→ (y ∈ x & t ∈ y))
** Аксиоматика ZFC
*** Аксиома равенства
    ∀x∀y∀z((x = y & y ∈ z) → x ∈ z)
    Eсли два множества равны, то любой элемент лежащий в первом,
    лежит и во втором
*** Аксиома пары
    ∀x∀y(¬(x=y) → ∃p(x ∈ p & y ∈ p & ∀z(z ∈ p → (x = z V y = z))))
    x ≠ y, тогда сущ. {x, y}
*** Аксиома объединений
    ∀x(∃y(y∈x) → ∃p∀y(y ∈ p ←→ ∃s(y ∈ s & s ∈ x)))
    Eсли x не пусто, то из любого семейства множеств можно
    образовать „кучу-малу“, то есть такое множество p,
    каждый элемент y которого принадлежит по меньшей мере
    одному множеству s данного семейства s x
*** Аксиома степени
    ∀x∃p∀y(y ∈ p ←→ y ∈ x)
    P(x) - множество степени x (не путать с 2ˣ - булеаном)
    Это типа мы взяли наш x, и из его элементов объединением и
    пересечением например понаобразовывали кучу множеств, а потом
    положили их в p.
*** Схема аксиом выделения
    ∀x∃b∀y(y ∈ b ←→ (y ∈ x & φ(y)))
    Для нашего множества x мы можем подобрать множество побольше,
    на котором для всех элементов, являющихся подмножеством x
    выполняется предикат.
*** Аксиома выбора (не входит в ZF по дефолту)
    Если a = Dj(x) и a ≠ 0, то x ∈ a ≠ 0
*** Аксиома бесконечности
    ∃N(∅ ∈ N & ∀x(x ∈ N → x ∪ {x} ∈ N))
*** Аксиома фундирования
    ∀x(x = ∅ V ∃y(y ∈ x & y ∩ x = ∅))
    ∀x(x ≠ ∅ → ∃y(y ∈ x & y ∩ x = ∅))
    Равноценные формулы.

    Я бы сказал, что это звучит как-то типа
    "не существует бесконечно вложенных множеств"
*** Схема аксиом подстановки
    ∀x∃!y.φ(x,y) → ∀a∃b∀c(c ∈ b ←→ (∃d.(d ∈ a & φ(d, c))))
    Пусть формула φ такова, что для при любом x найдется единственный y
    такой, чтобы она была истинна на x, y, тогда для любого a
    найдется множество b, каждому элементу которого c можно сопоставить
    подмножество a и наша функция будет верна на нем и на c
    Типа для хороших функций мы можем найти множество с отображением из
    его элементов в подмножество нашего по предикату.
* Ticket 14: oрдиналы
** Ординальные числа
   * Определение вполне упорядоченного множества (фундированное
     с линейныи порядком).
   * Определение транзитивного множества
     Множество X транзитивно, если
     ∀a∀b((a ∈ b & b ∈ x) → a ∈ x)
   * Ординал - транзитивное вполне упорядоченное отношением ∈ мн-во
   * Верхняя грань множества ординалов S
     C | {C = min(X) & C ∈ X | X = {z | ∀(y∈S)(z ≥ y)}}
     C = Upb(S)
     Upb({∅}) = {∅}
   * Successor ordinal (сакцессорный ординал?)
     Это b = a' = a ∪ {a}
   * Предельный ординал
     Ординал, не являющийся ни 0 ни successor'ом.
   * Недостижимый ординал
     ε - такой ординал, что ε = w^ε
     ε₀ = Upb(w, w^w, w^w^w, w^w^w^w, ...) - минимальный из ε
   * Канторова форма - форма вида ∑(a*w^b+c), где b - ординал, последовательность
     строго убывает по b. Есть слабая канторова форма, где вместо a (a ∈ N)
     пишут a раз w^b. В канторовой форме приятно заниматься сложениями и
     прочим, потому что всякие upb - слишком ниочем.
** Операции над ординальными числами
*** Стабилизация убывающей последовательности
    Допустим, что есть убывающая последовательность ординалов x₁,x₂...
    Возьмем ординал x₁ + 1 = x₀. Тогда {x₁, x₂, ...} ∈ x₀. x₀ не пусто,
    значит там есть минимальный элемент по определению порядка на ординале.
    Пусть этот элемент - m. Тогда поскольку m ∈ x₀, то m = xᵢ для какого-то
    i нашей убывающей последовательности.
    1. Последовательность убывает нестрого.
       Тогда все xₖ ≤ m, для k > i. Это выполняется, если xₖ = xᵢ, тогда
       последовательность стабилизируется в m.
    2. Последовательность убывает строго.
       Тогда все xₖ < m для k > i, но m - минимум множества. Противоречие.
       Убывающей строго последовательности ординалов не существует.
*** Арифметические операции через Upb
    Пусть lim(a) = предельный ординал a

    x + 0       = x
    x + c'      = (x + c)'
    x + lim(a)  = Upb{x + c | c < a}

    x * 0       = 0
    x * c'      = x * c + x
    x * lim(a)  = Upb{x * c | c < a}

    x ^ 0       = 1
    x ^ c'      = xᶜ * x
    x ^ lim(a)  = Upb{xᶜ | c < a}

    Ну вот короче можно так, только приходится много думать
    как реализовывать Upb. Или только у меня так.

    2^w = Upb(2, 4, 8, ...) = w
*** Арифметические операции через Канторову форму
    Хорошо описано в этой статье:
    [[http://www.google.ru/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CB4QFjAA&url=http://www.ccs.neu.edu/home/pete/pub/cade-algorithms-ordinal-arithmetic.pdf&ei=FDW6VJOYNuvXyQPd0ILQBQ&usg=AFQjCNENBOBOdKbbqBYN3iFhmAu_jFD2Sw&sig2=1UISFzJ_21I8f1YScX7Tkw&bvm=bv.83829542,d.bGQ&cad=rjt][Algorithms for Ordinal Arithmetic]]
    Переписывать довольно громоздко, учитывая количество вспомогательных
    функций. Есть в моем гитхабе (/volhovm/mathlogic/) реализованное
* Ticket 15: кардиналы
** Кардинальные числа
   Будем называть множества равномощными, если найдется биекция.
   Будем называть A не превышающим по мощности B, если найдется
   инъекция A → B (|A| ≤ |B|)
   Будем называть А меньше по мощности, чем B, если |A| ≤ |B| & |A| ≠ |B|
   Кардинальное число - число, оценивающее мощность множества.
   Кардинальное число ℵ - это ординальное число a, такое что
   ∀ x ≤ a |x| ≤ |a|
   ℵ₀ = w по определению; ℵ₁ = минимальный кардинал, следующий за ℵ₀
   Кардинальное число ℶ - это ординальное число а, такое что
   ℶᵢ = P(ℶᵢ₋₁)
   ℶ₀ = ℵ₀
   Континуум-гипотеза формулируется таким образом: |P(ℵ₀)| = ℵ₁ или ℶ₁ = ℵ₁
   В 40 году Гёдель доказал недоказуемость отрицания Континуум-гипотезы
   в терминах ZFC, в 60 Коэн сделал то же самое но без отрицания. Это все
   в условиях непротиворечивости ФА. То есть в ZFC нельзя доказать или
   опровергнуть континуум-гипотезу.
   Сложение кардинальных чисел - |A| + |B| = |A∪B| если в них
   нету общих элементов, иначе max(|A|, |B|), поскольку мы можем
   построить двумерную таблицу из перес. элементов.
   Остальное есть на вики и вряд ли нужно вообще.
** Диагональный метод Кантора
   Докажем, что для любого множества |x| < |P(x)|
   Воспользуемся диагональным методом Kантора
   Пусть |x|=|P(x)|
   Выпишем таблицу, в которой  столбцу p и строке q соответствует
   1, если в множестве X лежит p, а в множестве P(X) лежит
   множество, содержащее в себе p. Построим ключевое мн-во t:
   элемент лежит в t, если на i-й диагональной позиции не стоит 1
   и наоборот. То есть это множество всех таких элементов из X,
   которым по биекции соответствует множество о чем угодно, но не
   о самом элементе (не включающее элемент).
   t состоит из подмножеств X, тогда оно должно лежать в P(X).
   Докажем, что строка t не присутствует в таблице, сравнив ее с
   каждой другой строкой - от каждой n-й строки отличается в n-й
   столбце по построению.
   Противоречие - t нет в таблице, но t ∈ P(X).
** Теорема Лёвингейма-Скулема
   * Назовем мощностью модели мощность ее носителя (V или P или V∪P).
     M - модель, |M| - ее мощность, ну ясно.
   * Элементарная подмодель
     Пусть M - модель фс первого порядка с носителем D. Пусть определено
     D₁ ⊂ D, тогда структура M₁ построенная на D₁ так, что в ее интерпретации
     лежит все, что и в интерпретации M, кроме элементов, взаимодействующих
     с M \ M₁ (сужение области определения на D₁), называется *элементарной*
     *подмоделью*, если:
     1. Любая функция ФС, над которой рассматривается M, замкнута на
        D₁ (то есть если a ∈ D₁, b ∈ D₁, ... то f(a, b, ...) ∈ D₁)
     2. Любая формула A(x₁...xₙ) теории при любых аргументах из D₁,
        истинная в M истинна и в M₁.
   * Элементарная подмодель теории - модель теории
     Рассмотрим формулу А, она общазначима в М, значит и в М₁, тогда M₁ корректна.
   * Счетно-аксиоматизируемая теория - множество аксиом ФС имеет мощность ℵ₀
   * ФА и ТМ счетно-аксоиматизируемые
   * Пусть M - модель, T - мн-во формул теории. Тогда ∃M₁ : |M₁| = max(|T|, ℵ₀)
     Нужно построить необходимое предметное множество и доказать,
     что модель на нем - это подмодель.
     1. Построение множества
        Пусть у нас есть множество D', тогда D'' = D' ∪ P, где P - некоторое
        множество формул добавленное при рассмотрении формул D' по одной.
        A(y, x₁...xₙ) - n-местная формула из Т. Фиксируем x₁...xₙ из D'.
        * Если А = И или А = Л (тождественно) при любом y ∈ D - пропустим формулу
        * Если А = И или А = Л при каких-то y ∈ D' - пропустим формулу
        * ∃y: A(y,..) = И, но при этом ∀y∈D' A(y,..) = Л - тогда добавим один из
          тех у, на которых формула истинна, в D''. Добавим еще констант, которые
          нужны для вычисления А. Типа если В D' не хватает переменных для того,
          чтобы показать что A может принимать истинностное значение, сгенерим
          и добавим такое.
        Переход от предыдущего множества к текущему увеличивает его не более чем на
        ℵ₀ * |T| * |D'| - max(ℵ₀, T)
        Рассмотрим D₀, D₀ ⊂ D такое, что в него входят те элементы носителя,
        соответствующие константам, упоминающимся в Т. Если оно пустое -- добавим
        какую-нибудь константу из D. Оно ляжет в начало счетной последовательности
        D₀ ⊂ D₁ ⊂ ... (каждый переход описан выше). D* = ∪Dᵢ.
        D* - нужное нам множество. |D*| = max(ℵ₀, T)
     2. Проверка структуры
        Индукция по структуре.
        * База. Предикат.
          P(f₁(x₁...xₙ), ..., fₖ(x₁...xₙ)). Если x₁...xₙ взяты из D*, то они были
          добавлены на некотором шаге, значит ∃t | xᵢ ∈ Dₜ. Тогда на шаге Dₜ₊₁
          лежат результаты функций f₁...fₖ. по построению. Тогда оценка формулы
          сохраняется.
        * Переход
          Связки X&Y, XVY, X→Y, ¬X работают на сужении модели и оценка сохр.
          * ∃yB(y, x₁...xₙ). Фиксируем x₁...xₙ из D*.
            1. A была тождественно истинна или ложна - все ОК
            2. А принимала значения разных знаков
               Каждый xᵢ добавлен на каком-то шаге, тогда возьмем максимальный
               шаг t, в Dₜ₊₁ уже лежат все эти xᵢ.
               Тогда по построению Dₜ₊₁ мы добавили нужный y такой что B(y, x₁...xₙ)
               определено и выполнено в M.
               Значит B выполнено в M* по индукции, тогда A истинна в M*.
        * ∀yB(y, x₁...xₙ).
          1. Тождественно - ОК
          2. Принимает значения разных знаков
             Если оно истинно в M, тогда оно истинно в M* по 1 пункту перехода.
             Если ∀yB(y, x₁...xₙ) было ложно на t-шаге, тогда на t+1 шаге мы
             здоровски исправили ситуацию, положив в мир y на котором оно истинно.
             Если оно было истинно, то по пункту 2 пошло дальше.

          Таким образом, D* - подмодель нашего множества, |D*| = ℵ₀ + |T|
** Парадокс Скулема
   Мнимый парадокс Сколема формулируется так:
   Возьмем теорию, прикрутим модель с аксиоматикой ZF. Модель
   будет счетно-аксиоматизируемой потому что ZF.
   Утверждается, что в ZF ⊢ ∃x(|x| = ℶ₁) - это доказывает диагон.
   метод Кантора.
   Тогда получается что по теореме Лёвингейма-Скулема у нашей
   модели есть подмодель размером ℵ₀ + ℵ₀(счетно-акс) = ℵ₀, но
   мы можем взять то самое x | |x| = ℶ₁, и его занумеровать, выходит.

   Формальный подход не допускает этого конфликта ввиду одного
   простого факта:
   Рассмотрим отношение существования несчетного мн-ва в R.
   ZF ⊢ ¬∃f(f - биецкия между w и P(w)) & ∃f(f - биецкия между w и w∪w)
   // второе гарантирует счетность
   Первый аргумент конъюнкции - ¬∃f(∀x∀y(<x,y>∈f ←→ x∈A&x∈B))
   <x,y> - пара (типа {x, y, {x}})
   Тогда это значит, что в носителе модели нет такого f, что он
   бы представлял собой объединение пар.
   Собственно, по теореме Лёвингейма-Скулема у нас любая подмодель
   будет иметь счетный носитель. Нет никакого противоречия, потому
   что мы все еще работаем со счетным количеством множеств, а
   отсутствие биекции все так же выражается отсутствием множества
   в носителе.
* Ticket 16: неполнота ФА
** Теорема о трансфинитной индукции
   Пусть есть формула с одной свободной переменной a(x)
   a истинна, если
   1. a(0)
   2. Если для любого конечного p - ординала мы можем
      показать следование { a(q) & q < p => a(p) }, то a(p) истинно.

   Без док-ва, не требуется.

** Построение S∞
   Мы строим еще одну теорию I порядка.
   По сути, мы вкладываем ФА в нашу теорию так, что
   любое доказательство ФА работает в S∞ и мы можем доказать
   доказать непротиворечивость любого "импортированного" д-ва

   1. Формулы:
      Оставим связки ∀x, V, ¬
      Заметим, что {V, ¬} полно для {0, 1}.
   2. Доказательство
      Доказательством является дерево утверждений, в
      узлах которого правли, причем если дерево
      растет вверх, то правила действуют сверху вниз.
   3. Аксиомы:
      1. все термы ФА без переменных типа θ₁=θ₂ (корректные)
      2. все термы вида ¬(θ₁=θ₂) если [θ₁]≠[θ₂] (некорректные, все остальн.)
   4. Правила:
      Примечание: в правилах используются боковые формулы,
      они могут отсутствовать. Это сделано для формализации
      того факта, что мы можем применять правило для двух любых
      элементов нашей дизъюнкции или вроде того.
      Примечение: org-mode подчеркивает a, если "_a_"
      1) Структурные
         1. Перестановка
            _aVbVγVσ_
            aVγVbVσ
         2. Сокращение
            _aVbVbVγ_
            aVbVγ
      2) Сильные
         1. Ослабление
            _γ_
            aVγ
         2. Де-Морган
            _(¬a)Vγ_(¬b)Vγ_
            ¬(aVb)Vγ
         3. Отрицание
            _aVγ___
            (¬¬a)Vγ
         4. Квантификация
            _¬a(t)Vγ_
            ¬∀x.a(x)Vγ
         5. Бесконечная индукция
            _a(0~)Vγ_a(1~)Vγ_ ... _a(r~)Vγ_...
            ∀xa(x)Vγ
      3) Сечение (для облегчения жизни)
         _γVa_¬aVδ_
         γVδ
   5. Порядки
      Каждой формуле в дереве соответствует порядок, причем
      посылке и заключению (выше и ниже ___) слабого правила
      вывода соответствует один порядок, а порядковое число,
      отнесенное заключению сильного правила или сечения, больше
      порядковых чисел, отнесенных соотвтетствующим посылкам.
      Порядковые числа - это ординалы, они могут быть достижимыми,
      но не конечными - пусть формула какая-нибудь околорекурсивная
      типа Ф(x): Ф(0) = A → A, Ф(1) = A → A → A, Ф(2) = A → A → A → A.
      Тогда пусть мы хотим доказать ∀x.Ф(x) - по бесконечной
      индукции порядок термов будет увеличиваться, а порядок
      ∀x.Ф(x) будет w. Именно из-за этого факта мы используем
      в доказательстве теоремы об устранении сечений трансфинитную
      индукцию по порядку - ведь обычной индукции мало для порядков
      больших w.
   6. Степень
      Степень сечения - количество связок в ¬a.
      Степень доказательства - наибольшая степень сечения в дереве.
      Степень всегда конечна - любая формула в ФА содержит конечное
      число связок, а при трансляции нет возможности увеличить
      их количество. Тогда трансфинитная индукция по термам, в
      которых в сечении количество связок растет до бесконечности,
      невозможно.

   * Нитью называется последовательность формул от начальной до
     конечной. Все нити в доказательстве конечны, поскольку если в начальной
     формуле стоит ординал, последовательность в нити не возрастает, а эти
     числа убывают с применением строгого правила или сечения. Мы знаем,
     что строго убывающая бесконечная последовательность ординалов не существует.
     Добавим правило, что последовательность применения слабых правил подряд
     была всегда конечна
   * Теорема в S∞ - выражение, которое может стоять в заключительной формуле
     вывода
** Теоремы об эквивалентности ФА и S∞
*** Лемма 1: В S∞ выводимо AV¬A
    А либо корректна, либо некорректна, тогда
    _A_
    ¬AVA     ослабление

    _¬A_
    _AV¬A_   ослабление
    _¬AVA_   перестановка
*** Лемма 2: В S∞ выводимо s≠tV¬A(s)VA(t)
    Если выводимо A(s), s = t, то выводимо A(t) (все вхождения меняем)
    если s=t, то выводимо ¬A(t)VA(t), потом сделаем ослабление
    если s≠t, то она аксиома (некорректная) и ослабим.
*** Лемма 3: всякая выводимая в S замкнутая формула А является теоремой S∞
    Докажем, что если что-то доказуемо в ФА, то его эквивалент
    доказуем и в S∞.
    ⊢ₚₐA => ⊢ₛA'
    Схема док-ва
    Рассмотрим доказательство в ФА, оно состоит из
    β₁'...βₙ', оттранслируем каждое в βᵢ ∈ S∞ (по полноте {¬, V} это возможно)
    Тогда можно сделать дерево, в котором начальные формулы - аксиомы S,
    а правила вывода - MP, GEN.

    Рассмотрим формулу A = βᵢ
    1. B → C → B, те ¬B V (¬ C V B)
       Из замкнутости A следует замкнутость B
       ¬B V B выводима по Л1, тогда ослабим с ¬C, переставим.
    2. (B → C) → (B → C → D) → B → D
       ¬(¬B V C) V (¬(¬B V (¬C V D)) V (¬B V D))
       По Л1 выводимо ¬(¬B V C) V (¬B V C),
       (¬B V ¬C V D) V ¬(¬B V ¬C V D)
       Тогда можно по перестановке, сечению (с С) и сокращению
       доказать (B → C → D) → (B → C) → (B → D)
       что одно и то же, см дедукцию в предикатах
    3. (B → C) → (B → ¬C) → ¬B
       ¬(¬B V C) V ¬(¬B V ¬C) V ¬B
       1. ¬B V B                        л1
       2. ¬¬¬B V B                      отрицание
       3. ¬(¬¬B V C) V ¬¬¬B V B         ослабление
       4. ¬¬¬B V ¬(¬¬B V C) V B         перестановка
       5. ¬¬¬B V B V ¬¬C                аналогично + еще перестановка
       6. ¬C V ¬¬C                      лемма
       7. ¬C V B V ¬¬C                  ослабление + перестановка
       8. ¬(¬¬B V C) V B V ¬¬C          де-морган от 6 и 8
       9. ¬¬C V ¬(¬¬B V C) V B          перестановка 8
       10. ¬(¬¬B V ¬C) V ¬(¬¬B V C) V B де-морган от 4 и 9
       Ну вот мы доказали что-то очень похожее на то, что нужно было.
       Там контрпозиция, шмяк шмяк, готово.
    4. Видимо, примерно все формулы так доказываются.
    5. ∀x.B(x) → B(t)
       ¬∀x.B(x) V B(t)
       По л1 ¬B(t) V B(t), потом квантификация по 1 элем.
    6. B(t) → ∃x.B(x)
       B(t) → ¬∀x.B(x) (что заметно отличается от ∀x.¬B(x))
       ¬B(t) V ¬∀x.B(x)
       Не, я не знаю. Но точно можно! По бесконечной индукции мож как-то.
       Или там сечение хитрое.

    А еще есть аксиомы ФА
    1. a = b → a' = b'
       ¬(a = b) V a' = b'
       * если a = b, то a' = b', это аксиома S∞,
         тогда по ослаблению добавим ¬(a = b)
       * если a ≠ b, то она же и аксиома
    2. a = b → a = c → b = c
       a ≠ b V a ≠ c V b = c
       a ≠ b V ¬(x = c) @ b V (x = c) @ c     по лемме 2
    3. a' = b' → a = b
       Аналогично 1
    4. ¬(a' = 0)
       Аксиома, поскольку a' всегда имеет с 0 разные значения
    5. a + b' = (a + b)'
       TODO
    6. a + 0 = a
       Аксиома, поскольку это вседа равенство
    7. a * 0 = 0
       аналогично 6
    8. a * b' = a * b + a
       TODO
    9. φ[x:=0] & ∀x.(φ → φ[x:=x']) → φ
       ¬B(0) V ¬∀x(¬B(x)VB(x')) V B(0)         лемма 1 и перестановка
       ¬B(0) V ¬(¬B(0) V B(1)) V ...           можно показать по индукции
       ... V ¬(¬B(k) V B(k')) V B(k')   (ослабление, перестановка, де-морган)
       ¬B(0) V ¬(∀x(¬B(x) V B(x'))) V B(k')    k раз квантификация, перестановки, сокращ.
       Применим бесконечную индукцию относительно первого
       и третьего терма и получим что надо.

    Окей, с аксиомами разобрались.
    И еще есть два правила вывода
    1. MP
       B            условие
       ¬B V A       условие
       A            сечение
    2. GEN
       B(x)         условие
       Продвигаясь от этой формулы вверх можно поменять все
       x на k, тогда верно
       ⊢ B(k)
       На основании принципа бесконечной индукции доказываем ∀xB(x)
    3. A → B(t) => A → ∀x.B(x)
       ¬A V B
       Заменим все вхождения перменной в доказательстве в
       ФА формулы ¬A V B на 0, 1, 2...,
       тогда по бесконечной индукции:
       ¬A V B(0), ¬A V B(1), ... ⊢ ¬A V ∀x.B   (только B(0) V ¬A везде)
    4. A(t) → B => ∃x.A(x) → B
       ¬A V B ⊢ ¬¬∀x.(¬A(x)) → B
       Заменим все вхождения свободной перменной t в ФА на конкретные.
       Получим счетное мн-во д-в ¬A(0) V B, ¬A(1) V B, ...
       по беск. индукции
       ∀x.¬A(x) V B
       ¬¬∀x.¬A(x) V B -  навесили двойное отрицание
*** Следствие: непротиворечивость S∞ влечет непротиворечивость S
    Пусть в S доказуемо ¬(0=0), тогда оно доказуемо и в
    S∞, тогда
    _AV0=0_¬(0=0)VA_          Аргументы получаются по ослаблению
    _AVA_
    A
** Теорема Генцена об устранении сечений
*** Лемма: сильные правила 2, 3, 5 обратимы
    Правила обратимы и их д-во имеет порядок и степень не больше,
    чем первоначальное
    Нам дают доказательство формулы, мы строим новое дерево,
    в котором из результата следуют посылки.
    1. Правило Де-Моргана
       ¬(B V E) V D
       Рассмотрим вывод формулы. Проследим вхождения
       подформул ¬(B V E)  вормулы, которые соответствуют
       вхождению в конечную формулу (то есть не те, которые
       исчезают в сечении). Мы пройдем через всякий случай
       применения слабого правила и сильные, когда ¬(B V E)
       является боковой формулой. Остановка произойдет
       либо в ослаблении ( F ⊢ ¬(B V E) V F ) либо в Де-Моргане
       ( ¬B V F, ¬E V F ⊢ ¬(B V E) V F ). Совокупность таких
       вхождений формулы назовем ее *историей*.
       Если все вхождения формулы ¬(B V E) в ее истории заменить
       на ¬B, то в результате получится вывод ¬B V D. Аналогично
       можем вывести ¬E V D.
    2. Правило отрицания
       ¬¬B V D
       Заменим все вхождения ¬¬B в ее истории на B, получим
       вывод B V D
    3. Бесконечная индукция
       ∀xB(x) V D
       Заменим все вхождения ∀xB(x) в ее истории (1 элемент) на
       B(k) (причем если мы уткнулись в бесконечную индукцию,
       выберем только ту ветку, которая соответствует B(k))
       Тогда для любого k получим вывод B(k)
*** Теорема: устранение сечения
    Если для A в S∞ существует вывод (m, a), то существует
    вывод в S∞ (n, 2ᵃ), где n < m
    Докажем через трансфинитную индукцию по порядку a вывода A
    * База: порядок вывода 0
      Вывод не содержит сечений и его степень 0
    * Переход: пусть теорема верна для выводов порядков меньших a
      Будем продвигаться вверх по выводу, пока не встретим первое
      применение сильного правила или сечения.
      1. Сильное правило
         Пусть его посылки занумерованы порядковыми числами aₗ
         Согласно индуктивному предположению, для этих посылок
         существует дерево вывода F со степенью < m и порядком 2^(aᵢ).
         Заменим таким деревом то поддерево данного дерева вывода,
         заключительной формулой которого служит рассматриваемое
         вхождение F. Сделав так со всеми посылками мы получим новое
         дерево для A, отнесем ему порядковое число 2ᵃ > 2^(aᵢ)
         (пояснение от меня, потому что я чет долго доганял - каждую
         посылку заменяем по индукции на ее модное новое дерево
         от нее самой же).
      2. Сечение
         Значит имеем что-то на уровне
         _CVB__¬BVD_
         CVD
         Согласно индуктивному предположению для CVB и ¬BVD существуют
         выводы степеней меньших m и порядков 2^a₁, 2^a₂. Рассмотрим
         разные случаи строения B:
         1) B - это элементарная формула. Одна из формул B и ¬B есть
            аксиома. Пусть K - та, которая не аксиома.
            По предположениию поддерево основного дерева вывода с K
            может быть заменено другим со степенью n и порядка 2^(a_i)
            (i = 1 или 2, смотря в какой посылке K).
            В этом новом дереве расмотрим историю K, начальные формулы
            в которой могут возникнуть только по ослаблению (а исчезать
            по сечению). Поэтому удаление всех вхождений K из истории
            приводит к построению дерева вывода для D или C порядка
            2^aᵢ. Отсюда с помощью ослабления получаем дерево вывода
            для C V D порядка 2^a. Степень меньше m (одно сечение убрали).
         2) B - это ¬E, тогда посылки выглядят как
            CV¬E, ¬¬EVD
            Существует дерево вывода для ¬¬EVD степени < m и порядка 2^a₂
            В силу леммы об обратимости можно построить дерево вывода
            EVD порядка 2^a₂ степени < m
            Кроме того существует дерево вывода степени < m и порядка 2^a₁
            для левой посылки, тогда построим из них новое дерево
            вывода
            _EVD_   _CV¬E_
            _DVE__¬EVC_
            _DVC_
            CVD
            Степень выделенного здесь сечения на единицу меньше общего
            числа связок и кванторов в ¬E, которое само по себе ≤ m.
            Формуле CVD можно присвоить порядковое число C V D по свойству
            посылок новог сечения.
         3) B - это EVF, посылки:
            CVEVF, ¬(EVF)VD
            Существует дерево вывода для правой посылки < m и порядка 2^a₂,
            по лемме об обратимости существуют выводы степеней < m и порядка
            2^a₂ для ¬EVD и ¬FVD (по Де-Моргану). По предположению индукции
            есть еще дерево вывода для левой посылки.
            Из последних трех построим такое:
            _CVEVF__¬FVD_
               _CVEVD_
               _CVDVE____¬EVD_
                   _CVDVD_
            CVD
            Степень сечения уменьшили (в каждом на 1), в формуле
            CVEVD можно дать порядок 2^max(a₁, a₂)+1, а остальным - 2^a
         4) B - это ∀xE, посылки:
            CV∀xE  (¬∀xE)VD
            По индуктивному предположению для левой посылки можно построить
            дерево вывода (< m,2^a₁). В силу указания в начале 2 леммы о
            эквивалентности S∞ и ФА (если ⊢A(t), t=s, то ⊢A(s)) и леммы
            об обратимости для любого постоянного терма z существует вывод
            CVE(z).
            Можем и правую посылку заменить (< m, 2^a₂) по инд.предположению
            Тогда в правой посылке история ¬(∀xE) может начинаться либо
            с ослабления либо с квантификации.
            Заменим на C все такие начала - если это ослабление, то просто
            подменим вместо ¬(∀xE) новое C, если квантификация, то
            _¬E(t)VF___         _CVE(t)__¬E(t)VF_   //первое мы взяли из левой посылки
            ¬(∀xE(x))VF   =>          CVF
            В результате мы получили дерево вывода CVD
            Степень меньше m, поскольку связку мы одну убрали
            *тут еще ОЧЕНЬ АДОВЫЕ оценки порядка CVD, но он 2^a*
*** Следствие: устранение всех сечений
    Воспользуемся леммой об устранении сечения, пока степень вывода
    не станет равна нулю. Тогда порядок будет что-то на уровне степенной
    башни из двоек, в вершине которой первоначальная степень, а количество
    двоек -- количество применения леммы.
*** Следствие: S∞ непротивроечива
    Если S∞ противоречива, в ней докажется 0≠0V0≠0V...V0≠0.
    В ее истории появление 0≠0 может быть только из-за ослабления,
    но тогда посылкой ослабления тоже будет 0≠0. Если в д-ве есть
    сечения, мы можем перестроить его, устранив все сечения, а затем провести
    рассуждения вновь и увидеть, что такая формула недоказуема, а значит
    S∞ непротиворечива, значит и ФА тоже непротиворечива.
* Ключевые фигуры
  * Станислав Яськовски - 1906
    Aлгебра Яськовского, один из первых исследователей ИИВ
  * Герхард Генцен - 1909
    Теорема об устранении сечения (1935)
  * Курт Гёдель - 1906
    Теоремы о непротиворечивости - 1930
    Чуть ли не все остальное
  * Сол Крипке - 1940
    Семантика Крипке - 1960-1970
  * Дэвид Гильберт - 1862, Пауль Бернайс - 1888
    Основания математики - 1934, 39
  * Их достаточно много, а времени мало.
